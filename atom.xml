<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[赵元杰的技术博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://qq157755587.github.io//"/>
  <updated>2016-08-13T09:02:56.000Z</updated>
  <id>http://qq157755587.github.io//</id>
  
  <author>
    <name><![CDATA[赵元杰]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Chrome Custom Tabs最佳实践]]></title>
    <link href="http://qq157755587.github.io/2016/08/12/custom-tabs-best-practices/"/>
    <id>http://qq157755587.github.io/2016/08/12/custom-tabs-best-practices/</id>
    <published>2016-08-12T08:54:34.000Z</published>
    <updated>2016-08-13T09:02:56.000Z</updated>
    <content type="html"><![CDATA[<p>距离Google发布Chrome Custom Tabs已经一年，Twitter、Medium等国外App早已支持了这个功能，但遗憾的是国内App鲜有支持。这篇文章以官方<a href="https://developer.chrome.com/multidevice/android/customtabs" target="_blank" rel="external">开发文档</a>和<a href="https://github.com/GoogleChrome/custom-tabs-client" target="_blank" rel="external">示例源码</a>为基础，加上自己的理解，希望能帮助读者快速掌握Chrome Custom Tabs的用法。</p>
<h1 id="为什么要用Chrome_Custom_Tabs？">为什么要用Chrome Custom Tabs？</h1><p>当App需要打开一个网站时，开发者面临两种选择：默认浏览器或WebView。这两种选择都有不足。从App跳转到浏览器是一个非常重的切换，并且浏览器无法自定义；而WebView无法与浏览器共享cookies等数据，并且需要开发者处理非常多的场景。</p>
<p>Chrome Custom Tabs提供了一种新的选择，既能在App和网页之间流畅切换，又能有多种自定义选项。其实它本质上是调用了Chrome中的一个Activity来打开网页，这样想就能理解这些优点了。能自定义的项目有：</p>
<ul>
<li><p>Toolbar颜色</p>
</li>
<li><p>进场和出场动画</p>
</li>
<li><p>Toolbar上的action button，menu item和bottom toolbar（通过RemoveView实现）</p>
</li>
</ul>
<p>Chrome Custom Tabs还提供预启动Chrome和预加载网页内容的功能，与传统方式相比加载速度有显著提升。</p>
<p><img src="https://developer.chrome.com/multidevice/images/customtab/performance.gif" alt="alt"></p>
<h1 id="什么时候用Chrome_Custom_Tabs，什么时候用WebView？">什么时候用Chrome Custom Tabs，什么时候用WebView？</h1><p>如果Web页面是你自己的内容（比如淘宝商品页之于手机淘宝），那么WebView是最好的选择，因为你可能需要针对网页内容及用户操作做非常多的自定义。如果是跳到一个外部网站，比如在App中点了一个广告链接跳转到广告商的网站，那么建议使用Chrome Custom Tabs。</p>
<h1 id="前置条件">前置条件</h1><p>用户的手机上需要安装Chrome <strong>45</strong>或以上版本，并且<strong>设为默认浏览器</strong>。考虑到Chrome在国内手机上的占有率，这确实是个问题……但如果你的APP不只是面对国内市场，那么以Google在海外市场的影响力，这完全不是问题。</p>
<p>肯定有人要问，如果手机上没有装Chrome，调用Chrome Custom Tabs会发生什么行为呢？我们查看<code>CustomTabsIntent.Builder</code>的<a href="https://android.googlesource.com/platform/frameworks/support/+/c502e63/customtabs/src/android/support/customtabs/CustomTabsIntent.java#164" target="_blank" rel="external">源码</a>可以发现，Builder的内部构造了一个action为<code>Intent.ACTION_VIEW</code>的Intent，所以答案是调用默认浏览器来打开URL。</p>
<p>这时我们可以发现Chrome Custom Tabs的原理：如果Chrome是默认浏览器，那么这个Intent自然就会唤起Chrome，然后Chrome会根据Intent的各个Extra来配置前面所讲的自定义项。这里有一个隐藏的好处：<strong>如果你的工作恰好是开发浏览器，那么也可以根据这些Extra信息来定制界面！</strong></p>
<h1 id="开发向导">开发向导</h1><h2 id="快速上手">快速上手</h2><p>首先在你的<em>build.gradle</em>文件中加入dependency</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    compile <span class="string">'com.android.support:customtabs:24.1.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后写几行代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"https://www.google.com"</span>;</span><br><span class="line">CustomTabsIntent.Builder builder = <span class="keyword">new</span> CustomTabsIntent.Builder();</span><br><span class="line">CustomTabsIntent customTabsIntent = builder.build();</span><br><span class="line">customTabsIntent.launchUrl(<span class="keyword">this</span>, Uri.parse(url));</span><br></pre></td></tr></table></figure>
<p>就好了！不费吹灰之力~</p>
<p>注意launchUrl这个方法的第一个参数是个Activity。肯定有人会跳起来说，我要在ViewHolder里面处理点击跳转，根本拿不到Activity，只有Context肿么办？！！（其实这个人就是我）</p>
<p>那么我们看看launchUrl的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">launchUrl</span><span class="params">(Activity context, Uri url)</span> </span>&#123;</span><br><span class="line">    intent.setData(url);</span><br><span class="line">    ActivityCompat.startActivity(context, intent, startAnimationBundle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来是为了传入startAnimationBundle这个参数来实现自定义转场动画。那么我们自己处理一下就好了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">    customTabsIntent.launchUrl((Activity) context, uri);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Intent intent = customTabsIntent.intent;</span><br><span class="line">    intent.setData(uri);</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123;</span><br><span class="line">        context.startActivity(intent, customTabsIntent.startAnimationBundle);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改Toolbar颜色">修改Toolbar颜色</h2><p>你一定希望Chrome Custom Tabs的Toolbar颜色与你自己APP的Toolbar颜色保持相同，看起来就像是在APP内打开网页一样。一行代码搞定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.setToolbarColor(colorInt);</span><br></pre></td></tr></table></figure>
<h2 id="添加action_button">添加action button</h2><p>你可能想要在Toolbar上加上action button，那么需要创建一个PendingIntent。下面的代码增加了一个发送邮件的action button：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Intent actionIntent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">actionIntent.setType(<span class="string">"*/*"</span>);</span><br><span class="line">actionIntent.putExtra(Intent.EXTRA_EMAIL, <span class="string">"example@example.com"</span>);</span><br><span class="line">actionIntent.putExtra(Intent.EXTRA_SUBJECT, <span class="string">"example"</span>);</span><br><span class="line">PendingIntent pi = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, actionIntent, <span class="number">0</span>);</span><br><span class="line">Bitmap icon = BitmapFactory.decodeResource(getResources(), R.drawable.ic_share);<span class="comment">//注意在正式项目中不要在UI线程读取图片</span></span><br><span class="line">builder.setActionButton(icon, <span class="string">"send email"</span>, pi, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<h2 id="添加menu_item">添加menu item</h2><p>Chrome Custom Tabs的menu默认包含了三个显示为图标的item(Forward, Page Info, Refresh)和两个文字item(Find in page, Open in Browser)。我们可以再添加最多5个文字item。同样需要创建PendingIntent：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent menuIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">menuIntent.setClass(getApplicationContext(), SomeActivity.class);</span><br><span class="line">PendingIntent pi = PendingIntent.getActivity(getApplicationContext(), <span class="number">0</span>, menuIntent, <span class="number">0</span>);</span><br><span class="line">builder.addMenuItem(<span class="string">"Menu entry 1"</span>, pi);</span><br></pre></td></tr></table></figure>
<h2 id="设置转场动画">设置转场动画</h2><p>如果你的APP设置了转场动画，那么为了统一的用户体验，可以在Chrome Custom Tabs中设置同样的动画</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">builder.setStartAnimations(<span class="keyword">this</span>, R.anim.slide_in_right, R.anim.slide_out_left);</span><br><span class="line">builder.setExitAnimations(<span class="keyword">this</span>, R.anim.slide_in_left, R.anim.slide_out_right);</span><br></pre></td></tr></table></figure>
<h2 id="预启动(Warm_up)_Chrome和预加载">预启动(Warm up) Chrome和预加载</h2><p>默认情况下，调用了<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsIntent.html#launchUrl" target="_blank" rel="external">CustomTabsIntent#launchUrl</a>方法之后，才会在后台启动（原文是spin up）Chrome，然后加载网页。这个过程会花费宝贵的时间，并影响到用户体验。要是能「秒开」网页那就爽了。Chrome Custom Tabs可以绑定Chrome的一个Service，绑定成功之后可以预启动Chrome，还可以让Chrome预加载一些网页（当然这是要消耗一些流量的）。大致的过程是这样的：</p>
<ul>
<li>通过<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsClient.html#bindCustomTabsService" target="_blank" rel="external">CustomTabsClient#bindCustomTabsService</a>方法绑定Service。绑定成功后会得到一个CustomTabsClient的instance。如果绑定失败，说明Chrome版本过低或者没有安装。</li>
<li>通过<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsClient.html#warmup" target="_blank" rel="external">CustomTabsClient#warmup</a>方法在后台启动Chrome。</li>
<li>通过<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsClient.html#newSession" target="_blank" rel="external">CustomTabsClient#newSession</a>方法创建一个新的session。这一步还可以传入一个<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsCallback.html" target="_blank" rel="external">CustomTabsCallback</a>参数用来得到session的状态，比如页面是否加载完成。</li>
<li>通过<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsSession.html#mayLaunchUrl" target="_blank" rel="external">CustomTabsSession#mayLaunchUrl</a>来告诉Chrome要预加载哪些网页。</li>
<li>当用户点击事件发生时，将前面那个session传入<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsIntent.Builder.html" target="_blank" rel="external">CustomTabsIntent.Builder</a>，然后用文章最开头的方法打开网页。</li>
</ul>
<p>下面是完成这个过程的简单代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">ServiceConnectionCallback</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CustomTabsSession mSession;</span><br><span class="line">    <span class="keyword">private</span> CustomTabsClient mClient;</span><br><span class="line">    <span class="keyword">private</span> CustomTabsServiceConnection mConnection;</span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindCustomTabsService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mConnection = <span class="keyword">new</span> ServiceConnection(<span class="keyword">this</span>);</span><br><span class="line">        CustomTabsClient.bindCustomTabsService(<span class="keyword">this</span>, <span class="string">"com.android.chrome"</span>, mConnection);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">warmup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mClient != <span class="keyword">null</span>) mClient.warmup(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preLaunch</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mClent != <span class="keyword">null</span> &amp;&amp; mSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mSession = mClient.newSession(<span class="keyword">new</span> CustomTabsCallback(&#123;</span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNavigationEvent</span><span class="params">(<span class="keyword">int</span> navigationEvent, Bundle extras)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 这里可以取到Session的状态</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        mSession.mayLaunchUrl(Uri.parse(url), <span class="keyword">null</span>, <span class="keyword">null</span>);<span class="comment">//这里的第三个参数可以传入一些低优先级的Url，但不能保证会被预加载</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        CustomTabsIntent.Builder builder = <span class="keyword">new</span> CustomTabsIntent.Builder(mSession);</span><br><span class="line">        CustomTabsIntent customTabsIntent = builder.build();</span><br><span class="line">        customTabsIntent.launchUrl(<span class="keyword">this</span>, Uri.parse(url));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            unbindService(mConnection);</span><br><span class="line">            mClient = <span class="keyword">null</span>;</span><br><span class="line">            mSession = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** ServiceConnectionCallback的回调方法 */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(CustomTabsClient client)</span> </span>&#123;</span><br><span class="line">        mClient = client;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mClient = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单的预启动">简单的预启动</h2><p>Android Support Library 24.0.0开始加入了<a href="https://developer.android.com/reference/android/support/customtabs/CustomTabsClient.html#connectAndInitialize" target="_blank" rel="external">CustomTabsClient#connectAndInitialize</a>方法来简化预启动代码。如果你无法预料到用户会打开哪个URL，或者出于省电的考虑不想预加载URL，那么可以在Activity的onStart中加入一行代码来预启动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CustomTabsClient.connectAndInitialize(<span class="keyword">this</span>, <span class="string">"com.android.chrome"</span>);</span><br></pre></td></tr></table></figure>
<h1 id="最佳实践">最佳实践</h1><h2 id="绑定Custom_Tabs的service并预启动">绑定Custom Tabs的service并预启动</h2><p>预启动Chrome可以帮助你节省高达<strong>700ms</strong>的宝贵时间！这几乎是可以划分卡与不卡的差别。启动过程是在后台以低优先级进行，所以<strong>不会对你的APP性能有负面影响</strong>。</p>
<h2 id="预加载网页内容">预加载网页内容</h2><p>预加载网页后可以达到秒开的效果！所以如果你至少有50%的把握用户会打开某个URL，你应当调用<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsSession.html#mayLaunchUrl%28android.net.Uri,%20android.os.Bundle,%20java.util.List%3Candroid.os.Bundle%3E%29" target="_blank" rel="external">mayLaunchUrl()</a>方法。这个方法会提前下载并渲染网页内容，但不可避免的会有一点流量和电量的消耗。如果用户正在使用收费的数据流量，或者手机电量不足，那么这个方法不会生效。所以我们<strong>完全不用自己考虑性能优化</strong>。</p>
<h2 id="备选方案">备选方案</h2><p>如果用户的手机上没有安装Chrome，那么打开默认浏览器可能并不是最好的用户体验。所以如果在bindService那一步失败了，无论是打开默认浏览器还是WebView，选择一个你认为最好的备选方案。</p>
<h2 id="referrer">referrer</h2><p>很多网站都会统计自己的流量是从哪儿来的，所以最好告诉他们是你的帅气APP给他们带来了流量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intent.putExtra(Intent.EXTRA_REFERRER, </span><br><span class="line">        Uri.parse(Intent.URI_ANDROID_APP_SCHEME + <span class="string">"//"</span> + context.getPackageName()));</span><br></pre></td></tr></table></figure>
<h2 id="加入自定义动画">加入自定义动画</h2><p>自定义的转场动画会让你的网页跳转更流畅。确保进场动画和出场动画是反向的，比如网页从右边进来，就从右边出去，这样能帮助用户理解跳转关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">builder.setStartAnimations(<span class="keyword">this</span>, R.anim.slide_in_right, R.anim.slide_out_left);</span><br><span class="line">builder.setExitAnimations(<span class="keyword">this</span>, R.anim.slide_in_left, R.anim.slide_out_right);</span><br></pre></td></tr></table></figure>
<h2 id="为Action_Button选个合适的图标">为Action Button选个合适的图标</h2><p>一个合适的图标能让用户快速的理解到APP的功能。但记住图标的最大尺寸是宽48dp高24dp。</p>
<h2 id="其他支持的浏览器">其他支持的浏览器</h2><p>前面有讲到其他浏览器也有机会支持Custom Tabs的功能（虽然我还没发现有哪款已经支持了）。如果你检测到不止一个浏览器支持Custom Tabs，那么第一次调用时最好询问用户打算用哪个浏览器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns a list of packages that support Custom Tabs.</span><br><span class="line"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title">getCustomTabsPackages</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    PackageManager pm = context.getPackageManager();</span><br><span class="line">    <span class="comment">// Get default VIEW intent handler.</span></span><br><span class="line">    Intent activityIntent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, Uri.parse(<span class="string">"http://www.example.com"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get all apps that can handle VIEW intents.</span></span><br><span class="line">    List resolvedActivityList = pm.queryIntentActivities(activityIntent, <span class="number">0</span>);</span><br><span class="line">    ArrayList packagesSupportingCustomTabs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (ResolveInfo info : resolvedActivityList) &#123;</span><br><span class="line">        Intent serviceIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">        serviceIntent.setAction(ACTION_CUSTOM_TABS_CONNECTION);</span><br><span class="line">        serviceIntent.setPackage(info.activityInfo.packageName);</span><br><span class="line">        <span class="comment">// Check if this package also resolves the Custom Tabs service.</span></span><br><span class="line">        <span class="keyword">if</span> (pm.resolveService(serviceIntent, <span class="number">0</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            packagesSupportingCustomTabs.add(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> packagesSupportingCustomTabs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="给用户选择权">给用户选择权</h2><p>如果你的APP之前一直是用默认浏览器打开URL，后来才加入的Custom Tabs，那么老用户可能希望保留原来的习惯。可以考虑在设置里面增加一个选项，让用户自行选择。</p>
<h2 id="尽量让Native_APP处理URL">尽量让Native APP处理URL</h2><p>有些URL可以由Native APP处理。如果用户安装了Twitter的APP并且点击了Twitter的URL，他可能更期望用Twitter APP打开。所以在打开URL之前，检查看看手机里有没有其他APP可以处理这个URL。</p>
<h2 id="自定义Toolbar颜色">自定义Toolbar颜色</h2><p>如果你希望用户觉得网页内容是你的APP的一部分，那么就将Toolbar颜色设为你的primaryColor。如果希望清除的表明网页内容与APP无关，那么选个不同的颜色吧。</p>
<h2 id="增加一个分享按钮">增加一个分享按钮</h2><p>用户可能想要把URL分享给好友，但Custom Tabs默认并没有分享按钮，所以最好自己加个吧。</p>
<h2 id="自定义关闭按钮">自定义关闭按钮</h2><p>Custom Tabs左上角的关闭按钮默认是一个叉叉。如果你希望用户感觉到网页内容是APP的一部分，那么最好把叉叉换成返回按钮。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.setCloseButtonIcon(BitmapFactory.decodeResource(getResources(), R.drawable.ic_arrow_back));</span><br></pre></td></tr></table></figure>
<h2 id="分清内部链接和外部链接">分清内部链接和外部链接</h2><p>举个例子，如果用户在Twitter APP里点击了一个<code>http://twitter.com</code>开头的URL，那么应该在APP内部处理。Custom Tabs只应用来处理外部链接。</p>
<h2 id="处理连击">处理连击</h2><p>如果你想在用户点击URL到打开Custom Tabs之间的这段时间做一点准备工作，确保不要超过100ms，否则用户可能会觉得APP没有反应而再次点击。</p>
<p>然而你懂的在Android上是无法完全避免卡顿的，所以当用户反复点击同一个URL时，你应该只将URL打开一次。</p>
<h1 id="结尾">结尾</h1><p>如果你的APP是使用默认浏览器打开URL，那么身为一个合格的开发者，即使你的APP只在国内上架，也应该加入Custom Tabs支持。毕竟国内还是有一些会科学上网的用户使用Chrome的。更重要的是，<strong>我们这些开发者如果看到有国内APP使用了Custom Tabs，会欣慰的点个赞！</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>距离Google发布Chrome Custom Tabs已经一年，Twitter、Medium等国外App早已支持了这个功能，但遗憾的是国内App鲜有支持。这篇文章以官方<a href="https://developer.chrome.com/multidevice/an]]>
    </summary>
    
      <category term="chrome" scheme="http://qq157755587.github.io/tags/chrome/"/>
    
      <category term="customtabs" scheme="http://qq157755587.github.io/tags/customtabs/"/>
    
      <category term="Android" scheme="http://qq157755587.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kotlin在Android中的应用]]></title>
    <link href="http://qq157755587.github.io/2015/11/14/kotlin-in-android/"/>
    <id>http://qq157755587.github.io/2015/11/14/kotlin-in-android/</id>
    <published>2015-11-14T05:13:52.000Z</published>
    <updated>2015-11-14T07:27:22.000Z</updated>
    <content type="html"><![CDATA[<p>最近公司新开发了一个新App，android程序员就我一个人，爱咋写咋写~~于是我尝试用Kotlin完成了这个App。开发过程中越来越感动……太好用了！！！解决了android开发中的好多痛点！</p>
<h1 id="dp,_sp,_px间的转换">dp, sp, px间的转换</h1><p>传统的java写法通常是写个类似<code>Util.dpToPx(int value)</code>这样的方法。看看Kotlin是怎么通过<a href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank" rel="external">Extension</a>来优雅的解决的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Int.<span class="title">dpToPx</span><span class="params">()</span>: Int &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (toInt() <span class="keyword">in</span> intArrayOf(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)) &#123;</span><br><span class="line">        <span class="keyword">return</span> this</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (this * Global.density).toInt() <span class="comment">//这里的Gloabl.density是在应用启动时获取的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以这样写了：<code>params.topMargin = 16.dpTpPx()</code></p>
<p>是不是感动到哭😭</p>
<h1 id="设置View的宽高">设置View的宽高</h1><p>如果用java来写通常也是会有个Util方法<code>ViewHelper.setSize(View view, int width, int height)</code>，我每次在ViewHolder中调用一堆这样的方法都觉得很蛋疼……我们的救世主来了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">setSize</span><span class="params">(width: <span class="typename">Int, height: Int</span>)</span> &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> params</span> = layoutParams</span><br><span class="line">    params.width = width</span><br><span class="line">    params.height = height</span><br><span class="line">    layoutParams = params</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里的<code>layoutParams</code>是Kotlin将<code>setLayoutParams()</code>和<code>getLayoutParams()</code>自动转为了<a href="https://kotlinlang.org/docs/reference/properties.html" target="_blank" rel="external">Property</a>，写过C#的应该不会陌生。然后我们就可以愉快的写代码了~<code>yourView.setSize(100, 100)</code></p>
<h1 id="View的动画">View的动画</h1><p>每次写Animation都是一个头两个大……这回我们不看java了，直接上Kotlin代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">animateTopMargin</span><span class="params">(valueFromInDP: <span class="typename">Int, valueToInDP: Int, duration: Long</span> = 300)</span> &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> animation</span> = <span class="keyword">object</span>: Animation() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">applyTransformation</span><span class="params">(interpolatedTime: <span class="typename">Float, t: Transformation?</span>)</span> &#123;</span></span><br><span class="line">            <span class="variable"><span class="keyword">val</span> params</span> = layoutParams <span class="keyword">as</span> ViewGroup.MarginLayoutParams</span><br><span class="line">            <span class="variable"><span class="keyword">val</span> from</span> = valueFromInDP.dpToPx()</span><br><span class="line">            <span class="variable"><span class="keyword">val</span> to</span> = valueToInDP.dpToPx()</span><br><span class="line">            params.topMargin = from + ((to - from) * interpolatedTime).toInt()</span><br><span class="line">            layoutParams = params</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    animation.duration = duration</span><br><span class="line">    startAnimation(animation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哇，duration还贴心的设了个默认值呢！然后就可以这样写了~<code>yourView.animateTopMargin(16, 32)</code>或者你想把duration设长一点<code>yourView.animateTopMargin(16, 32, 500)</code></p>
<h1 id="让Fresco更易用">让Fresco更易用</h1><p><a href="http://github.com/facebook/fresco" target="_blank" rel="external">Fresco</a>是Facebook出品的网络图片加载库，实现了许多在android上非常有用的功能。比如<a href="http://frescolib.org/docs/requesting-multiple-images.html#_" target="_blank" rel="external">Multi-URI</a>功能可以优先显示低分辨率的图片，等高分辨率的图片下载完成后再进行替换。这个功能在移动设备上太太太有用了，就是写起来有点蛋疼：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Uri lowResUri, highResUri;</span><br><span class="line">DraweeController controller = Fresco.newDraweeControllerBuilder()</span><br><span class="line">    .setLowResImageRequest(ImageRequest.fromUri(lowResUri))</span><br><span class="line">    .setImageRequest(ImageRequest.fromUri(highResUri))</span><br><span class="line">    .setOldController(mSimpleDraweeView.getController())</span><br><span class="line">    .build();</span><br><span class="line">mSimpleDraweeView.setController(controller);</span><br></pre></td></tr></table></figure>
<p>于是我又祭出了神器Extension</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> SimpleDraweeView.<span class="title">setMultiUri</span><span class="params">(lowResUri: <span class="typename">Uri, highResUri: Uri</span>)</span> &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> newController</span> = Fresco.newDraweeControllerBuilder()</span><br><span class="line">            .setLowResImageRequest(ImageRequest.fromUri(lowResUri))</span><br><span class="line">            .setImageRequest(ImageRequest.fromUri(highResUri))</span><br><span class="line">            .setOldController(controller)</span><br><span class="line">            .build();</span><br><span class="line">    controller = newController</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后怎么使用我就不写了，大家都知道了:smiley:</p>
<h1 id="焕然一新的SharedPreference">焕然一新的SharedPreference</h1><p>你看到这里可能觉得不过是扩展方法嘛，Obj-C也可以做到啊，没什么嘛。哈哈哈哈图样图森破！有请<a href="https://kotlinlang.org/docs/reference/delegated-properties.html" target="_blank" rel="external">Delegated Properties</a>！下面这段代码来源于<a href="http://google.com/+OmarMiatello" target="_blank" rel="external">Omar Miatello</a>在今年米兰的GDG DevFest的<a href="https://goo.gl/7Vhy0s" target="_blank" rel="external">演讲</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppPreferences</span></span>(<span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> context</span>: Context) &#123;</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> preferences</span>: SharedPreferences = PreferenceManager.getDefaultSharedPreferences(context)</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> userName by PreferenceDelegates.string(defaultValue</span> = context.getString(R.string.user_name))</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> password by PreferenceDelegates.string()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object PreferenceDelegates &#123;</span><br><span class="line">    public fun string(defaultValue</span>: String? = <span class="literal">null</span>): ReadWriteProperty<span class="type">&lt;AppPreferences, String?&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PrefString(defaultValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefString</span></span>(<span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> defaultValue</span>: String?) : ReadWriteProperty<span class="type">&lt;AppPreferences, String?&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="typename">AppPreferences, property: KProperty&lt;*&gt;</span>)</span>: String? &#123;</span></span><br><span class="line">        <span class="keyword">return</span> thisRef.preferences.getString(property.name, defaultValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="typename">AppPreferences, property: KProperty&lt;*&gt;, value: String?</span>)</span> &#123;</span></span><br><span class="line">        thisRef.preferences.edit().putString(property.name, value).apply()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hmm，乍一看有点摸不着头脑呢……简单的讲，AppPreferences这个class里面有两个delegate property，分别是userName和password。他们的get和set方法分别对应了SharedPreference中的getString和setString方法。纳尼？这么神奇？？？接着往下看</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span>: <span class="typename">Application</span></span>() &#123;</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> pref by lazy &#123; AppPreferences(this) &#125;</span><br><span class="line">    </span><br><span class="line">    override fun onCreate() &#123;</span><br><span class="line">        super.onCreate()</span><br><span class="line">        // 其他代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在Application中定义了<code>pref</code>，注意它被<code>by lazy</code>修饰了，这样它就只在第一次调用的时候初始化，是不是很方便？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span>: <span class="typename">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> app by lazy &#123; application as App &#125;</span><br><span class="line">    <span class="keyword">val</span> pref by lazy &#123; app.pref &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里我们在所有Activity的父类中引入了pref，即AppPreferences的实例。然后……就可以爽了~~</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span>: <span class="typename">BaseActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="typename">Bundle?</span>)</span> &#123;</span></span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        </span><br><span class="line">        pref.userName = <span class="string">"Who"</span></span><br><span class="line">        pref.password = <span class="string">"You"</span></span><br><span class="line">        Log.d(<span class="string">"userName"</span>, pref.userName)</span><br><span class="line">        Log.d(<span class="string">"password"</span>, pref.password)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到没有，用起来简直和field一毛一样！再也不用写<code>pref.edit().putString(&quot;userName&quot;, &quot;Who&quot;).apply()</code>了！！！老板再也不用担心我把SharedPreference的key写错了😂</p>
<h1 id="Lambdas">Lambdas</h1><p>这个话题可就大了，一本书都讲不完，举个例子好了。<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a>现在很火，<a href="https://github.com/rengwuxian" target="_blank" rel="external">光头哥</a>写了一篇很好的<a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">文章</a>介绍了RxJava在android中的应用。抄一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">getUser(userId)</span><br><span class="line">    .doOnNext(<span class="keyword">new</span> Action1&lt;User&gt;() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">            processUser(user);</span><br><span class="line">        &#125;)</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Observer&lt;User&gt;() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">            userView.setUser(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Error handling</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>嗯，链式调用，很清晰，但用Kotlin还可以更简洁：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getUser(userId)</span><br><span class="line">    .doOnNext&#123; user -&gt; processUser(user) &#125;</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(&#123;</span><br><span class="line">        user -&gt; userView.setUser(user)</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        error -&gt; <span class="comment">// Error handling</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>Done!收拾东西下班回家~</p>
<h1 id="风险">风险</h1><p>我知道你在担心什么。Kotlin目前还是beta版，用于正式项目要评估风险。事实上在第一个beta版中就出现了在android 4.3设备上无法安装的bug，好在官方很快就修复了。怎么讲呢，这是需要项目组全体成员一起评估的问题。我之所以敢在实际项目中使用，一是因为项目比较简单，万一遇到不可解决的问题可以改用java写，反正Kotlin和java可以无缝混用；二是因为程序员就我一个人，胆子粗啊哈哈哈哈~</p>
<h1 id="感想">感想</h1><p>整个项目做下来让我感到很愉悦，代码的优雅足以说服我冒一点点风险。开发过程中我常常在想，要是有一个包含各种扩展方法的library就好了，我就不用自己造小轮子了。但转念一下，我真的需要一个完整的library吗？那必然会像<a href="https://github.com/google/guava" target="_blank" rel="external">Guava</a>一样成为一个巨无霸，但实际用到的功能可能只有10%。在Kotlin的<a href="http://kotlinslackin.herokuapp.com/" target="_blank" rel="external">官方Slack</a>里<a href="https://github.com/jakewharton" target="_blank" rel="external">Jake Wharton</a>（没错就是那个大神）提了一个有趣的思路：在一个git里放了很多不同类别的扩展方法文件（比如ViewExt.kt，IntExt.kt），需要哪个文件就把它pull下来，而不是compile整个jar包。如果能用gradle实现就太方便了😆</p>
<h1 id="补充资料">补充资料</h1><p><a href="http://antonioleiva.com/" target="_blank" rel="external">Antonio Leiva</a>写了一本书<a href="http://antonioleiva.com/kotlin-android-developers-book/" target="_blank" rel="external">Kotlin for Android Developers</a>，价格实惠干货满满，值得购买。配套的源码在<a href="https://github.com/antoniolg/Kotlin-for-Android-Developers" target="_blank" rel="external">https://github.com/antoniolg/Kotlin-for-Android-Developers</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近公司新开发了一个新App，android程序员就我一个人，爱咋写咋写~~于是我尝试用Kotlin完成了这个App。开发过程中越来越感动……太好用了！！！解决了android开发中的好多痛点！</p>
<h1 id="dp,_sp,_px间的转换">dp, sp, px间]]>
    </summary>
    
      <category term="Kotlin" scheme="http://qq157755587.github.io/categories/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[快速自定义tableViewCell]]></title>
    <link href="http://qq157755587.github.io/2015/08/19/custom-table-view-cell/"/>
    <id>http://qq157755587.github.io/2015/08/19/custom-table-view-cell/</id>
    <published>2015-08-19T12:47:01.000Z</published>
    <updated>2015-08-19T13:11:43.000Z</updated>
    <content type="html"><![CDATA[<p>最近因为工作需要开始学习iOS。在网上搜自动定义tableViewCell，出来的结果都是要新建xib文件和对应的class，然后在上面添加控件，再注册到tableViewController中。<br>这样做一来很繁琐，二来很容易在绑定outlet的时候抛异常（我就遇到了）。同事告诉我一个快捷的办法。</p>
<p>1、直接在StoryBoard里面将控件添加到Prototype Cell中。</p>
<p><img src="tableViewCell.png" alt="Image of tableViewCell"></p>
<p>2、新增一个Class（比如MyTableViewCell）继承UITableViewCell。</p>
<p>3、将Prototype Cell的Class设为MyTableViewCell。</p>
<p>4、按住<em>control</em>将控件拖到MyTableViewCell中，添加outlet。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) IBOutlet UILable *label;&#10;@property (nonatomic, strong) IBOutlet UIImageView *image;</span><br></pre></td></tr></table></figure></p>
<p>5、直接调用<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CELL_IDENTITY forIndexPath:indexPath];</span><br></pre></td></tr></table></figure></p>
<p>搞定~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近因为工作需要开始学习iOS。在网上搜自动定义tableViewCell，出来的结果都是要新建xib文件和对应的class，然后在上面添加控件，再注册到tableViewController中。<br>这样做一来很繁琐，二来很容易在绑定outlet的时候抛异常（我就遇到了]]>
    </summary>
    
      <category term="tableViewCell" scheme="http://qq157755587.github.io/tags/tableViewCell/"/>
    
      <category term="iOS" scheme="http://qq157755587.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kotlin学习笔记（三）控制流程]]></title>
    <link href="http://qq157755587.github.io/2015/08/08/learning-kotlin-3/"/>
    <id>http://qq157755587.github.io/2015/08/08/learning-kotlin-3/</id>
    <published>2015-08-08T06:40:18.000Z</published>
    <updated>2015-08-08T08:06:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="If_Expression">If Expression</h1><p>在Kotlin中，<strong>if</strong>是一个表达式，它有返回类型。因此Kotlin中不再需要三元表达式。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> max</span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure>
<p>if分支也可以是代码块（blocks），代码块的末尾是返回值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> max</span> = <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">  print(<span class="string">"Choose a"</span>)</span><br><span class="line">  a <span class="comment">// a会被赋值给max</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  print(<span class="string">"Choose b"</span>)</span><br><span class="line">  b <span class="comment">// b会被赋值给max</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="When_Expression">When Expression</h1><p><strong>when</strong>替代了switch语句，简单的例子像这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">  <span class="number">1</span> -&gt; print(<span class="string">"x == 1"</span>)</span><br><span class="line">  <span class="number">2</span> -&gt; print(<span class="string">"x == 2"</span>)</span><br><span class="line">  <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">    print(<span class="string">"x is neither 1 or 2"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果多个分支使用同样的处理逻辑，那么可以用逗号将它们结合起来：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">  <span class="number">1</span>, <span class="number">2</span> -&gt; print(<span class="string">"x == 1 or x == 2"</span>)</span><br><span class="line">  <span class="keyword">else</span> -&gt; print(<span class="string">"otherwise"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分支中除了使用常量（上例中的1、2），也可以使用函数（arbitrary expressions）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">  parseInt(s) -&gt; print(<span class="string">"s encodes x"</span>)</span><br><span class="line">  esle -&gt; print(<span class="string">"s does not encode x"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以用<strong>in</strong>或<strong>!in</strong>判断一个值是否在一个范围（range）或集合（collection）中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">  <span class="keyword">in</span> <span class="number">1.</span>..<span class="number">10</span> -&gt; print(<span class="string">"x is in the range"</span>)</span><br><span class="line">  <span class="keyword">in</span> validNumbers -&gt; print(<span class="string">"x is valid"</span>)</span><br><span class="line">  !<span class="keyword">in</span> <span class="number">10.</span>..<span class="number">20</span> -&gt; print(<span class="string">"x is outside the range"</span>)</span><br><span class="line">  <span class="keyword">else</span> -&gt; print(<span class="string">"none of the above"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以用<strong>is</strong>或<strong>!is</strong>来检查一个值是否是某个类型：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> hasPrefix</span> = <span class="keyword">when</span>(x) &#123;</span><br><span class="line">  <span class="keyword">is</span> String -&gt; x.startsWith(<span class="string">"prefix"</span>) <span class="comment">// 注意这里s已经被自动转为String类型了</span></span><br><span class="line">  <span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>when还可以用来取代<strong>if-else if</strong>。如果没有传参数，那么分支条件就是简单的boolean表达式，当条件为true时分支就会被执行：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">  x.isOdd() -&gt; print(<span class="string">"x is odd"</span>)</span><br><span class="line">  x.isEven() -&gt; print(<span class="string">"x is even"</span>)</span><br><span class="line">  <span class="keyword">else</span> -&gt; print(<span class="string">"x is funny"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="For_Loops">For Loops</h1><p>感觉没什么特别的，跟Java一样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection)</span><br><span class="line">  print(item)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array.indices)</span><br><span class="line">  print(array[i])</span><br></pre></td></tr></table></figure>
<h1 id="While_Loops">While Loops</h1><p>也没什么特别的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  x--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="variable"><span class="keyword">val</span> y</span> = retrieveData()</span><br><span class="line">&#125; <span class="keyword">while</span> (y != <span class="literal">null</span>) <span class="comment">// 注意虽然y是在大括号内部定义的，但这里仍然可以访问到</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="If_Expression">If Expression</h1><p>在Kotlin中，<strong>if</strong>是一个表达式，它有返回类型。因此Kotlin中不再需要三元表达式。</p>
<figure class="highlight kotli]]>
    </summary>
    
      <category term="for" scheme="http://qq157755587.github.io/tags/for/"/>
    
      <category term="if" scheme="http://qq157755587.github.io/tags/if/"/>
    
      <category term="when" scheme="http://qq157755587.github.io/tags/when/"/>
    
      <category term="while" scheme="http://qq157755587.github.io/tags/while/"/>
    
      <category term="Kotlin" scheme="http://qq157755587.github.io/categories/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kotlin学习笔记（二）基本类型]]></title>
    <link href="http://qq157755587.github.io/2015/07/28/learning-kotlin-2/"/>
    <id>http://qq157755587.github.io/2015/07/28/learning-kotlin-2/</id>
    <published>2015-07-28T10:31:26.000Z</published>
    <updated>2015-07-30T09:51:37.000Z</updated>
    <content type="html"><![CDATA[<p>如果你学过Ruby，你一定知道“万物皆对象”。Kotlin中也一样。即便数字(Numbers)在Kotlin中是基本类型，也可以这样写：<code>123.toString()</code></p>
<p>下面我们来看一下Kotlin中的基本类型。</p>
<h1 id="Numbers">Numbers</h1><p>Kotlin提供的数字类型和Java很像：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>Type</strong></th>
<th style="text-align:center"><strong>Bitwidth</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Double</td>
<td style="text-align:center">64</td>
</tr>
<tr>
<td style="text-align:center">Float</td>
<td style="text-align:center">32</td>
</tr>
<tr>
<td style="text-align:center">Long</td>
<td style="text-align:center">64</td>
</tr>
<tr>
<td style="text-align:center">Int</td>
<td style="text-align:center">32</td>
</tr>
<tr>
<td style="text-align:center">Short</td>
<td style="text-align:center">16</td>
</tr>
<tr>
<td style="text-align:center">Byte</td>
<td style="text-align:center">8</td>
</tr>
</tbody>
</table>
<p>值得注意的是，定义Long形要用大写L：<strong>123L</strong></p>
<p>而16进制和二进制则和Java一样：<strong>0x0F</strong> <strong>0b0101</strong></p>
<p>8进制则不支持。</p>
<p>浮点型和Java一样，类似<strong>123.45</strong>默认为Double类型，想要Float类型则应写成<strong>123.45f</strong></p>
<p>在Java平台中，Number是基本类型。如果需要一个可空的数字（比如Int?）或者泛型，数字就会被装箱(boxed)：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> a</span>: <span class="typename">Int</span> = <span class="number">10000</span></span><br><span class="line">print(a == a) <span class="comment">// Prints 'true'</span></span><br><span class="line">print(a === a) <span class="comment">// Prints 'true'</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> boxedA</span>: <span class="typename">Int</span>? = a</span><br><span class="line"><span class="variable"><span class="keyword">val</span> anotherBoxedA</span>: <span class="typename">Int</span>? = a</span><br><span class="line">print(boxedA == anotherBoxedA) <span class="comment">// Prints 'true'</span></span><br><span class="line">print(boxedA === anotherBoxedA) <span class="comment">// !!!Prints 'false'!!!</span></span><br></pre></td></tr></table></figure>
<p><code>==</code>相当于调用<code>equals</code>方法。而<code>===</code>相当于Java中的<code>==</code>，用来比较引用对象。</p>
<p>注意在官方的<a href="http://kotlinlang.org/docs/reference/basic-types.html#representation" target="_blank" rel="external">Reference</a>中用的是即将被deprecated的<code>identityEquals</code>，会得到错误的结果，详情参看 <a href="http://stackoverflow.com/questions/31666155/kotlins-identityequals-not-working-as-expected" target="_blank" rel="external">http://stackoverflow.com/questions/31666155/kotlins-identityequals-not-working-as-expected</a></p>
<p>Kotlin中，数字类型<strong>不能</strong>像Java一样隐式(implicitly)转换类型。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> a</span>:<span class="typename">Int</span>? = <span class="number">1</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> b</span>:<span class="typename">Long</span>? = a <span class="comment">// 这里会编译报错，Int不能转换成Long</span></span><br><span class="line">print(a == b) <span class="comment">// 这里会编译报错，Int和Long不能进行比较</span></span><br></pre></td></tr></table></figure>
<p>而所有的数字类型都有如下显示方法：</p>
<ul>
<li>toByte()</li>
<li>toShort()</li>
<li>toInt()</li>
<li>toLong()</li>
<li>toFloat()</li>
<li>toDouble()</li>
<li>toChar()</li>
</ul>
<p>写惯Java的人可能觉得这样会很不方便，但事情也没有那么糟糕。因为运算符可以帮我们隐式的转换数字类型：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> l</span> = <span class="number">1.</span>toLong() + <span class="number">3</span> <span class="comment">// Long + Int =&gt; Long</span></span><br></pre></td></tr></table></figure>
<p>仅Int和Long可以进行位运算。运算符与Java不同：</p>
<ul>
<li>shl(bits) 有符号的左位移，在Java中是<code>&lt;&lt;</code></li>
<li>shr(bits) 有符号的右位移，在Java中是<code>&gt;&gt;</code></li>
<li>ushr(bits) 无符号的右位移，在Java中是<code>&gt;&gt;&gt;</code></li>
<li>and(bits) 与，在Java中是<code>&amp;</code></li>
<li>or(bits) 或，在Java中是<code>|</code></li>
<li>xor(bits) 异或，在Java中是<code>^</code></li>
<li>inv() 非，在Java中是<code>~</code></li>
</ul>
<h1 id="Characters">Characters</h1><p>Int不能直接转为Char，下面的代码会编译报错：</p>
<p><code>val a:Char = 1</code></p>
<p>但是Char可以通过<code>toInt()</code>方法转为Int。</p>
<p>同数字一样，如果需要一个可空类型（Char?），那么这个Char会被自动装箱（boxed）。</p>
<h1 id="Booleans">Booleans</h1><p>没什么好说的，也是自动装箱的问题。</p>
<h1 id="Arrays">Arrays</h1><p>Kotlin中的数组写法与Java区别很大，有专门的<code>Array</code>类来创建和操作数组。</p>
<p>如果我想创建一个[1, 2, 3]数组，可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> a</span>:Array<span class="type">&lt;Int&gt;</span> = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 注意这里的数字装箱了</span></span><br><span class="line">a[<span class="number">0</span>] = a[<span class="number">1</span>] + a[<span class="number">2</span>] <span class="comment">// 这里的操作与Java一样</span></span><br></pre></td></tr></table></figure>
<p>还可以像这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates an Array&lt;String&gt; with values ["0", "1", "4", "9", "16"]</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> asc</span> = Array(<span class="number">5</span>, &#123;i -&gt; (i * i).toString()&#125;)</span><br></pre></td></tr></table></figure>
<p>如果想要一个空数组，可以使用<code>arrayOfNulls(size: Int)</code>方法。</p>
<p>如果不想装箱，Kotlin也提供一些原子类型（primitive type）的数组，如<code>IntArray</code>，<code>ShortArray</code>等。这些类型没有继承<code>Array</code>类型，但是拥有相同的方法。每个类型都有对应的工厂方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> x</span>: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">x[<span class="number">0</span>] = x[<span class="number">1</span>] + x[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h1 id="Strings">Strings</h1><p><code>s.[0]</code>相当于Java中的<code>s.charAt(0)</code></p>
<p>还可以使用iterator：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (c <span class="keyword">in</span> str) &#123;</span><br><span class="line">    println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin包含两种类型的字符串：与Java字符串相同的escaped strings和新的raw strings。escaped strings中的换行符是<code>\n</code>，而raw strings就厉害了。看这个例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val text = """</span><br><span class="line">    for (c in "foo")</span><br><span class="line">    print(c)</span><br><span class="line">"""</span><br></pre></td></tr></table></figure>
<p>注意第二行和第三行都是字符串，它们被包含在三个引号中。</p>
<p>Kotlin中再也不用写繁琐的<code>String.format</code>了，只需要一个<code>$</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> i</span> = <span class="number">10</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> s</span> = <span class="string">"i = $i"</span> <span class="comment">// evaluates to "i = 10"</span></span><br></pre></td></tr></table></figure>
<p>甚至可以像这样写表达式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> s</span> = <span class="string">"abc"</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> str</span> = <span class="string">"$s.length is $&#123;s.length&#125;"</span> <span class="comment">// evaluates to "abc.length is 3"</span></span><br></pre></td></tr></table></figure>
<p><em>这篇是用<a href="http://typora.io/" target="_blank" rel="external">Typora</a>写的，确实很好用，而且是国人出品！</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果你学过Ruby，你一定知道“万物皆对象”。Kotlin中也一样。即便数字(Numbers)在Kotlin中是基本类型，也可以这样写：<code>123.toString()</code></p>
<p>下面我们来看一下Kotlin中的基本类型。</p>
<h1 id="]]>
    </summary>
    
      <category term="array" scheme="http://qq157755587.github.io/tags/array/"/>
    
      <category term="boolean" scheme="http://qq157755587.github.io/tags/boolean/"/>
    
      <category term="character" scheme="http://qq157755587.github.io/tags/character/"/>
    
      <category term="number" scheme="http://qq157755587.github.io/tags/number/"/>
    
      <category term="string" scheme="http://qq157755587.github.io/tags/string/"/>
    
      <category term="Kotlin" scheme="http://qq157755587.github.io/categories/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kotlin学习笔记（一）基本语法]]></title>
    <link href="http://qq157755587.github.io/2015/07/24/learning-kotlin-1/"/>
    <id>http://qq157755587.github.io/2015/07/24/learning-kotlin-1/</id>
    <published>2015-07-24T10:37:27.000Z</published>
    <updated>2015-07-25T12:01:07.000Z</updated>
    <content type="html"><![CDATA[<p>先提个问题</p>
<h1 id="Android程序员为什么要学Kotlin？">Android程序员为什么要学Kotlin？</h1><ol>
<li>Java不争气。在1.5时代Java或许还能和C#谈笑风生，而现在C#不知道比Java高明到哪里去了。虽然Java8中也加入了闭包等有用的特性，但Android又不支持……</li>
<li><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a>。想象这样一个需求：用户连续点击某个区域10次且每次间隔不超过500毫秒，则触发一个彩蛋。<br>实现这个需求很容易，但代码会很混乱。我们得自己控制计时器，保存时间戳，可能还会有令人讨厌的空接口。如果用RxJava来做，几行代码就能搞定。如果再配合Kotlin的函数式编程，简直不能更爽~<br>关于RxJava的使用，网上已经有很多了。我有空了可能也会写一些。</li>
<li>如果你尝试了<a href="https://developer.android.com/tools/data-binding/guide.html" target="_blank" rel="external">Android Databinding</a>，有没有发现External Libraries里面多了kotlin-runtime和kotlin-stdlib？<br>Google内部正是用Kotlin开发的Databinding。虽然短期内Kotlin还不太可能成为Android官方开发语言，但至少这是个好的迹象。</li>
</ol>
<h1 id="为什么是Kotlin？">为什么是Kotlin？</h1><p>现在替代Java的选择有很多，Scala、Groovy都能写Android，甚至微软最新发布的Visual Studio都能进来插一脚，为什么要选<a href="http://kotlinlang.org/" target="_blank" rel="external">Kotlin</a>呢？<br>这又是另一个很大的话题了。请参看大神Jake Wharton的这篇<a href="https://docs.google.com/document/d/1ReS3ep-hjxWA8kZi0YqDbEhCqTt29hG8P44aA9W0DM8/edit" target="_blank" rel="external">文章</a>（要翻墙）。</p>
<p>那么进入正题。我的学习步骤基本是按照官方的<a href="http://kotlinlang.org/docs/reference/" target="_blank" rel="external">Reference</a>来，所以可能写着写着就成了翻译官方文档了……哈哈哈哈</p>
<h1 id="Function">Function</h1><p>最开始学C的时候，我们会说为了实现XXX写个函数（Function），学Java就变成了写个方法（Method），现在Kotlin又变成函数了……<br>所以我后面提到Java的时候会说Method，提到Kotlin的时候会说Function，其实都是一个意思~</p>
<p>先看下Java中的写法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后是Kotlin<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span>: Int &#123;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>区别：</p>
<ol>
<li>用fun开头</li>
<li>数据类型写在后面</li>
<li>结尾不用写分号</li>
</ol>
<p>这语法让我想起了Action Script，写惯了Java再来写Kotlin总觉得有些别扭……</p>
<p>如果想简洁一点可以这样写在一行里，并且返回值类型可以是隐式（inferred）的。不过我个人不太喜欢这样写。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span> = a + b</span></span><br></pre></td></tr></table></figure>
<p>如果是public function就必须显式的标明返回类型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span>: Int = a + b</span></span><br></pre></td></tr></table></figure>
<p>没有返回值则用<strong>Unit</strong>关键字</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span>: Unit &#123;</span></span><br><span class="line">    print(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使函数是public的，Unit也可以省略掉<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span> &#123;</span></span><br><span class="line">    print(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="local_variables">local variables</h1><p>只读变量（read-only）用<strong>val</strong>定义<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> a</span>: <span class="typename">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> b</span> = <span class="number">1</span> <span class="comment">// 如果赋了初始值值，可以省略数据类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> c</span>: <span class="typename">Int</span> <span class="comment">// 否则需要指定类型</span></span><br><span class="line">c = <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>可变变量（mutable）用<strong>var</strong>定义<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> x</span> = <span class="number">5</span></span><br><span class="line">x += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h1 id="string_templates">string templates</h1><p>用<strong>${}</strong>包住变量就行了，这比Java中的String.valueof方便多了<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> a</span> = <span class="number">1</span></span><br><span class="line">print(<span class="string">"Value of a: $&#123;a&#125;"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="conditional_expressions">conditional expressions</h1><p>看起来有点像三元表达式，但可读性更强<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span> = <span class="title">if</span> <span class="params">(a &gt; b)</span> a <span class="keyword">else</span> b</span></span><br></pre></td></tr></table></figure></p>
<h1 id="nullable_values">nullable values</h1><p>写java的同学一定受够了NullPointerException吧。Kotlin与Java很大不同的一点就是显示的标明了value是否可能为空。<br>如果可能为空，则用<strong>?</strong>注明<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> x</span>: <span class="typename">Int</span>?</span><br></pre></td></tr></table></figure></p>
<p>先知道有这么回事就行了，后面的章节会详细说明。</p>
<h1 id="type_checks_&amp;_automatic_casts">type checks &amp; automatic casts</h1><p>和C#一样，用<strong>is</strong>操作符来判断变量的类型<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="typename">Any</span>)</span>: Int? &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">is</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj.length <span class="comment">// 注意这里obj已经自动转成String类型了，所以可以调用length方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// 这里obj依然是Any类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="loop">loop</h1><p>和Java相比是把冒号改成了<strong>in</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="typename">Array&lt;String&gt;</span>)</span> &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (arg <span class="keyword">in</span> args)</span><br><span class="line">        print(arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="while_loop">while loop</h1><p>和Java基本一样<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="typename">Array&lt;String&gt;</span>)</span> &#123; </span></span><br><span class="line">    <span class="variable"><span class="keyword">var</span> i</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (i <span class="type">&lt; args.size())</span><br><span class="line">        print(args[i++]) </span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="when_expression">when expression</h1><p><strong>when</strong>可以类比Java中的<strong>switch case</strong>，但是更加强大，可以接受各种操作符<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cases</span><span class="params">(obj: <span class="typename">Any</span>)</span> &#123; </span></span><br><span class="line">    <span class="keyword">when</span> (obj) &#123;</span><br><span class="line">        <span class="number">1</span> -&gt; print(<span class="string">"One"</span>)</span><br><span class="line">        <span class="string">"Hello"</span> -&gt; print(<span class="string">"Greeting"</span>)</span><br><span class="line">        <span class="keyword">is</span> <span class="typename">Long</span> -&gt; print(<span class="string">"Long"</span>)</span><br><span class="line">        !<span class="keyword">is</span> String -&gt; print(<span class="string">"Not a string"</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; print(<span class="string">"Unknow"</span>)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="ranges">ranges</h1><p><strong>in</strong>操作符太好用了，我就不贴对应的Java代码了，因为想想就觉得麻烦……<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x <span class="keyword">in</span> <span class="number">1.</span>.y-<span class="number">1</span>) </span><br><span class="line">    print(<span class="string">"OK"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (x !<span class="keyword">in</span> <span class="number">0.</span>.array.lastIndex) </span><br><span class="line">    print(<span class="string">"Out"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.</span>.<span class="number">5</span>) </span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure></p>
<h1 id="collections">collections</h1><p>collections配合in使用很方便<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (text <span class="keyword">in</span> names) <span class="comment">// 这里调用了names.contains(text) </span></span><br><span class="line">    print(<span class="string">"Yes"</span>)</span><br></pre></td></tr></table></figure></p>
<p>如果配合函数式编程和Lambdas表达式就不能更爽……<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names filter &#123; it.startsWith(<span class="string">"A"</span>) &#125; </span><br><span class="line">      sortBy &#123; it &#125; </span><br><span class="line">      map &#123; it.toUpperCase() &#125; </span><br><span class="line">      forEach &#123; print(it) &#125;</span><br></pre></td></tr></table></figure></p>
<p>注意这里函数前面没有小圆点（<strong>.</strong>），这个大概是特有的简写，后面再慢慢学吧~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>先提个问题</p>
<h1 id="Android程序员为什么要学Kotlin？">Android程序员为什么要学Kotlin？</h1><ol>
<li>Java不争气。在1.5时代Java或许还能和C#谈笑风生，而现在C#不知道比Java高明到哪里去了。虽然Java8中]]>
    </summary>
    
      <category term="syntax" scheme="http://qq157755587.github.io/tags/syntax/"/>
    
      <category term="Kotlin" scheme="http://qq157755587.github.io/categories/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Android中将文本转为曲线]]></title>
    <link href="http://qq157755587.github.io/2015/07/18/android-convert-text-to-curves/"/>
    <id>http://qq157755587.github.io/2015/07/18/android-convert-text-to-curves/</id>
    <published>2015-07-18T08:09:27.000Z</published>
    <updated>2015-07-20T10:24:14.000Z</updated>
    <content type="html"><![CDATA[<p>最近在Android平台上生成PDF文件时，碰到了内嵌字体的问题。大部分打印厂的机器是不支持PDF内嵌字体的，<br>所以要想将文字按指定的字体印刷出来，只能<a href="http://baike.baidu.com/subview/8597409/8551998.htm" target="_blank" rel="external">转曲</a>。</p>
<h1 id="转曲">转曲</h1><p>转曲的意思就是把文字转成曲线线段，可以想象成把文字的轮廓勾勒出来。<br>Android中的<a href="http://developer.android.com/reference/android/graphics/Paint.html#getTextPath(java.lang.String, int, int, float, float, android.graphics.Path" target="_blank" rel="external">Paint.getTextPath</a><br>方法可以获得String的Path，而<a href="http://developer.android.com/reference/android/graphics/PathMeasure.html" target="_blank" rel="external">PathMeasure</a>可以获得Path中的关键点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Paint paint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">paint.setTextSize(yourTextSize);</span><br><span class="line">Path fontPath = <span class="keyword">new</span> Path();</span><br><span class="line">paint.getTextPath(yourText, <span class="number">0</span>, yourText.length(), <span class="number">0f</span>, paint.getFontSpacing(), fontPath);</span><br><span class="line">PathMeasure pathMeasure = <span class="keyword">new</span> PathMeasure(fontPath, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">float</span>[] pos = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">2</span>]; <span class="comment">// pos用来存放每一个关键点</span></span><br><span class="line">do &#123;</span><br><span class="line">    <span class="keyword">float</span> distance = <span class="number">0f</span>;</span><br><span class="line">    <span class="keyword">while</span> (distance &lt; pathMeasure.getLength()) &#123;</span><br><span class="line">        pathMeasure.getPosTan(distance, pos, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 在这里将pos设置到你自己的曲线里</span></span><br><span class="line">        <span class="comment">// 我使用PDFjet生成PDF，那么这里就将pos保存到com.pdfjet.Point中</span></span><br><span class="line">        distance += <span class="number">0.1f</span>; <span class="comment">// 0.1f是每个关键点的间隔。间隔越大轮廓越粗糙，反之越细腻。如果设的过小会影响性能。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (pathMeasure.nextContour());<span class="comment">// nextContour会跳到下一段曲线</span></span><br></pre></td></tr></table></figure>
<h1 id="计算曲线嵌套层数">计算曲线嵌套层数</h1><p>得到文字曲线后还不能直接印刷，因为我们只是得到了文字的轮廓，还得往轮廓里填色。<br>当然不能所有轮廓都填黑色，这样文字会变成一坨一坨的黑色……<br>我们需要计算每条曲线被多少条曲线全包围（注意我们现在得到的曲线全都是头尾相连的）。<br>如果被偶数条曲线（包含0条）包围，则填黑色；如果被奇数条曲线包围，则填白色（底色）。<br>Android或Java本身不提供这样的方法，还好已经有人帮我们研究出方法了，详细参看<a href="http://alienryderflex.com/polygon/。" target="_blank" rel="external">http://alienryderflex.com/polygon/。</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Polygon coodinates.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span>[] polyY, polyX;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Number of sides in the polygon.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> polySides;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Default constructor.</span><br><span class="line">     * <span class="doctag">@param</span> px Polygon y coods.</span><br><span class="line">     * <span class="doctag">@param</span> py Polygon x coods.</span><br><span class="line">     * <span class="doctag">@param</span> ps Polygon sides count.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Polygon</span><span class="params">( <span class="keyword">float</span>[] px, <span class="keyword">float</span>[] py, <span class="keyword">int</span> ps )</span> </span>&#123;</span><br><span class="line">        polyX = px;</span><br><span class="line">        polyY = py;</span><br><span class="line">        polySides = ps;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Checks if the Polygon contains a point.</span><br><span class="line">     * <span class="doctag">@see</span> "http://alienryderflex.com/polygon/"</span><br><span class="line">     * <span class="doctag">@param</span> x Point horizontal pos.</span><br><span class="line">     * <span class="doctag">@param</span> y Point vertical pos.</span><br><span class="line">     * <span class="doctag">@return</span> Point is in Poly flag.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">( <span class="keyword">float</span> x, <span class="keyword">float</span> y )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> oddTransitions = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>, j = polySides -<span class="number">1</span>; i &lt; polySides; j = i++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span>((Float.compare(polyY[i], y) &lt; <span class="number">0</span> &amp;&amp; Float.compare(polyY[j], y) &gt;= <span class="number">0</span> ) || ( Float.compare(polyY[j], y) &lt; <span class="number">0</span> &amp;&amp; Float.compare(polyY[i], y) &gt;= <span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(Float.compare(polyX[i] + ( y - polyY[i] ) / ( polyY[j] - polyY[i] ) * ( polyX[j] - polyX[i] ), x) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    oddTransitions = !oddTransitions;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oddTransitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Polygon的构造方法前两个参数填多边形（可以将曲线理解为多边形）横坐标和纵坐标的数组，第三个参数填多边形的边数，即坐标的个数。<br>contains方法即可检查某个点是否在这个多边形中。<br>那么思路就很简单了：如果曲线A的任一关键点不在曲线B中，B就没有包围A。<br>代码就不贴了。</p>
<h1 id="填色">填色</h1><p>如上所述，如果被偶数条曲线包围，填黑色；被奇数条曲线包围，填白色。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nestingNum = surroundedNumber(pathPointsList, pathPoints);</span><br><span class="line"><span class="keyword">if</span> (nestingNum % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    paint.setColor(Color.BLACK);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    paint.setColor(Color.WHITE);</span><br><span class="line">&#125;</span><br><span class="line">canvas.drawPath(path, paint);</span><br></pre></td></tr></table></figure>
<p>大功告成~</p>
<p>详细代码请参考<a href="https://gist.github.com/qq157755587/32e927e77e259cd84631" target="_blank" rel="external">https://gist.github.com/qq157755587/32e927e77e259cd84631</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在Android平台上生成PDF文件时，碰到了内嵌字体的问题。大部分打印厂的机器是不支持PDF内嵌字体的，<br>所以要想将文字按指定的字体印刷出来，只能<a href="http://baike.baidu.com/subview/8597409/8551998.ht]]>
    </summary>
    
      <category term="PDF" scheme="http://qq157755587.github.io/tags/PDF/"/>
    
      <category term="Paint" scheme="http://qq157755587.github.io/tags/Paint/"/>
    
      <category term="Path" scheme="http://qq157755587.github.io/tags/Path/"/>
    
      <category term="Android" scheme="http://qq157755587.github.io/categories/Android/"/>
    
  </entry>
  
</feed>