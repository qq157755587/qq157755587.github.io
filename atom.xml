<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[赵元杰的技术博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://qq157755587.github.io//"/>
  <updated>2015-11-14T07:27:22.000Z</updated>
  <id>http://qq157755587.github.io//</id>
  
  <author>
    <name><![CDATA[赵元杰]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Kotlin在Android中的应用]]></title>
    <link href="http://qq157755587.github.io/2015/11/14/kotlin-in-android/"/>
    <id>http://qq157755587.github.io/2015/11/14/kotlin-in-android/</id>
    <published>2015-11-14T05:13:52.000Z</published>
    <updated>2015-11-14T07:27:22.000Z</updated>
    <content type="html"><![CDATA[<p>最近公司新开发了一个新App，android程序员就我一个人，爱咋写咋写~~于是我尝试用Kotlin完成了这个App。开发过程中越来越感动……太好用了！！！解决了android开发中的好多痛点！</p>
<h1 id="dp,_sp,_px间的转换">dp, sp, px间的转换</h1><p>传统的java写法通常是写个类似<code>Util.dpToPx(int value)</code>这样的方法。看看Kotlin是怎么通过<a href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank" rel="external">Extension</a>来优雅的解决的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Int.<span class="title">dpToPx</span><span class="params">()</span>: Int &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (toInt() <span class="keyword">in</span> intArrayOf(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)) &#123;</span><br><span class="line">        <span class="keyword">return</span> this</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (this * Global.density).toInt() <span class="comment">//这里的Gloabl.density是在应用启动时获取的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以这样写了：<code>params.topMargin = 16.dpTpPx()</code></p>
<p>是不是感动到哭😭</p>
<h1 id="设置View的宽高">设置View的宽高</h1><p>如果用java来写通常也是会有个Util方法<code>ViewHelper.setSize(View view, int width, int height)</code>，我每次在ViewHolder中调用一堆这样的方法都觉得很蛋疼……我们的救世主来了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">setSize</span><span class="params">(width: <span class="typename">Int, height: Int</span>)</span> &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> params</span> = layoutParams</span><br><span class="line">    params.width = width</span><br><span class="line">    params.height = height</span><br><span class="line">    layoutParams = params</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里的<code>layoutParams</code>是Kotlin将<code>setLayoutParams()</code>和<code>getLayoutParams()</code>自动转为了<a href="https://kotlinlang.org/docs/reference/properties.html" target="_blank" rel="external">Property</a>，写过C#的应该不会陌生。然后我们就可以愉快的写代码了~<code>yourView.setSize(100, 100)</code></p>
<h1 id="View的动画">View的动画</h1><p>每次写Animation都是一个头两个大……这回我们不看java了，直接上Kotlin代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">animateTopMargin</span><span class="params">(valueFromInDP: <span class="typename">Int, valueToInDP: Int, duration: Long</span> = 300)</span> &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> animation</span> = <span class="keyword">object</span>: Animation() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">applyTransformation</span><span class="params">(interpolatedTime: <span class="typename">Float, t: Transformation?</span>)</span> &#123;</span></span><br><span class="line">            <span class="variable"><span class="keyword">val</span> params</span> = layoutParams <span class="keyword">as</span> ViewGroup.MarginLayoutParams</span><br><span class="line">            <span class="variable"><span class="keyword">val</span> from</span> = valueFromInDP.dpToPx()</span><br><span class="line">            <span class="variable"><span class="keyword">val</span> to</span> = valueToInDP.dpToPx()</span><br><span class="line">            params.topMargin = from + ((to - from) * interpolatedTime).toInt()</span><br><span class="line">            layoutParams = params</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    animation.duration = duration</span><br><span class="line">    startAnimation(animation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哇，duration还贴心的设了个默认值呢！然后就可以这样写了~<code>yourView.animateTopMargin(16, 32)</code>或者你想把duration设长一点<code>yourView.animateTopMargin(16, 32, 500)</code></p>
<h1 id="让Fresco更易用">让Fresco更易用</h1><p><a href="http://github.com/facebook/fresco" target="_blank" rel="external">Fresco</a>是Facebook出品的网络图片加载库，实现了许多在android上非常有用的功能。比如<a href="http://frescolib.org/docs/requesting-multiple-images.html#_" target="_blank" rel="external">Multi-URI</a>功能可以优先显示低分辨率的图片，等高分辨率的图片下载完成后再进行替换。这个功能在移动设备上太太太有用了，就是写起来有点蛋疼：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Uri lowResUri, highResUri;</span><br><span class="line">DraweeController controller = Fresco.newDraweeControllerBuilder()</span><br><span class="line">    .setLowResImageRequest(ImageRequest.fromUri(lowResUri))</span><br><span class="line">    .setImageRequest(ImageRequest.fromUri(highResUri))</span><br><span class="line">    .setOldController(mSimpleDraweeView.getController())</span><br><span class="line">    .build();</span><br><span class="line">mSimpleDraweeView.setController(controller);</span><br></pre></td></tr></table></figure>
<p>于是我又祭出了神器Extension</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> SimpleDraweeView.<span class="title">setMultiUri</span><span class="params">(lowResUri: <span class="typename">Uri, highResUri: Uri</span>)</span> &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> newController</span> = Fresco.newDraweeControllerBuilder()</span><br><span class="line">            .setLowResImageRequest(ImageRequest.fromUri(lowResUri))</span><br><span class="line">            .setImageRequest(ImageRequest.fromUri(highResUri))</span><br><span class="line">            .setOldController(controller)</span><br><span class="line">            .build();</span><br><span class="line">    controller = newController</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后怎么使用我就不写了，大家都知道了:smiley:</p>
<h1 id="焕然一新的SharedPreference">焕然一新的SharedPreference</h1><p>你看到这里可能觉得不过是扩展方法嘛，Obj-C也可以做到啊，没什么嘛。哈哈哈哈图样图森破！有请<a href="https://kotlinlang.org/docs/reference/delegated-properties.html" target="_blank" rel="external">Delegated Properties</a>！下面这段代码来源于<a href="http://google.com/+OmarMiatello" target="_blank" rel="external">Omar Miatello</a>在今年米兰的GDG DevFest的<a href="https://goo.gl/7Vhy0s" target="_blank" rel="external">演讲</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppPreferences</span></span>(<span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> context</span>: Context) &#123;</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> preferences</span>: SharedPreferences = PreferenceManager.getDefaultSharedPreferences(context)</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> userName by PreferenceDelegates.string(defaultValue</span> = context.getString(R.string.user_name))</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> password by PreferenceDelegates.string()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object PreferenceDelegates &#123;</span><br><span class="line">    public fun string(defaultValue</span>: String? = <span class="literal">null</span>): ReadWriteProperty<span class="type">&lt;AppPreferences, String?&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PrefString(defaultValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefString</span></span>(<span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> defaultValue</span>: String?) : ReadWriteProperty<span class="type">&lt;AppPreferences, String?&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="typename">AppPreferences, property: KProperty&lt;*&gt;</span>)</span>: String? &#123;</span></span><br><span class="line">        <span class="keyword">return</span> thisRef.preferences.getString(property.name, defaultValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="typename">AppPreferences, property: KProperty&lt;*&gt;, value: String?</span>)</span> &#123;</span></span><br><span class="line">        thisRef.preferences.edit().putString(property.name, value).apply()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hmm，乍一看有点摸不着头脑呢……简单的讲，AppPreferences这个class里面有两个delegate property，分别是userName和password。他们的get和set方法分别对应了SharedPreference中的getString和setString方法。纳尼？这么神奇？？？接着往下看</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span>: <span class="typename">Application</span></span>() &#123;</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> pref by lazy &#123; AppPreferences(this) &#125;</span><br><span class="line">    </span><br><span class="line">    override fun onCreate() &#123;</span><br><span class="line">        super.onCreate()</span><br><span class="line">        // 其他代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在Application中定义了<code>pref</code>，注意它被<code>by lazy</code>修饰了，这样它就只在第一次调用的时候初始化，是不是很方便？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span>: <span class="typename">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> app by lazy &#123; application as App &#125;</span><br><span class="line">    <span class="keyword">val</span> pref by lazy &#123; app.pref &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里我们在所有Activity的父类中引入了pref，即AppPreferences的实例。然后……就可以爽了~~</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span>: <span class="typename">BaseActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="typename">Bundle?</span>)</span> &#123;</span></span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        </span><br><span class="line">        pref.userName = <span class="string">"Who"</span></span><br><span class="line">        pref.password = <span class="string">"You"</span></span><br><span class="line">        Log.d(<span class="string">"userName"</span>, pref.userName)</span><br><span class="line">        Log.d(<span class="string">"password"</span>, pref.password)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到没有，用起来简直和field一毛一样！再也不用写<code>pref.edit().putString(&quot;userName&quot;, &quot;Who&quot;).apply()</code>了！！！老板再也不用担心我把SharedPreference的key写错了😂</p>
<h1 id="Lambdas">Lambdas</h1><p>这个话题可就大了，一本书都讲不完，举个例子好了。<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a>现在很火，<a href="https://github.com/rengwuxian" target="_blank" rel="external">光头哥</a>写了一篇很好的<a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">文章</a>介绍了RxJava在android中的应用。抄一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">getUser(userId)</span><br><span class="line">    .doOnNext(<span class="keyword">new</span> Action1&lt;User&gt;() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">            processUser(user);</span><br><span class="line">        &#125;)</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Observer&lt;User&gt;() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">            userView.setUser(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Error handling</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>嗯，链式调用，很清晰，但用Kotlin还可以更简洁：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getUser(userId)</span><br><span class="line">    .doOnNext&#123; user -&gt; processUser(user) &#125;</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(&#123;</span><br><span class="line">        user -&gt; userView.setUser(user)</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        error -&gt; <span class="comment">// Error handling</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>Done!收拾东西下班回家~</p>
<h1 id="风险">风险</h1><p>我知道你在担心什么。Kotlin目前还是beta版，用于正式项目要评估风险。事实上在第一个beta版中就出现了在android 4.3设备上无法安装的bug，好在官方很快就修复了。怎么讲呢，这是需要项目组全体成员一起评估的问题。我之所以敢在实际项目中使用，一是因为项目比较简单，万一遇到不可解决的问题可以改用java写，反正Kotlin和java可以无缝混用；二是因为程序员就我一个人，胆子粗啊哈哈哈哈~</p>
<h1 id="感想">感想</h1><p>整个项目做下来让我感到很愉悦，代码的优雅足以说服我冒一点点风险。开发过程中我常常在想，要是有一个包含各种扩展方法的library就好了，我就不用自己造小轮子了。但转念一下，我真的需要一个完整的library吗？那必然会像<a href="https://github.com/google/guava" target="_blank" rel="external">Guava</a>一样成为一个巨无霸，但实际用到的功能可能只有10%。在Kotlin的<a href="http://kotlinslackin.herokuapp.com/" target="_blank" rel="external">官方Slack</a>里<a href="https://github.com/jakewharton" target="_blank" rel="external">Jake Wharton</a>（没错就是那个大神）提了一个有趣的思路：在一个git里放了很多不同类别的扩展方法文件（比如ViewExt.kt，IntExt.kt），需要哪个文件就把它pull下来，而不是compile整个jar包。如果能用gradle实现就太方便了😆</p>
<h1 id="补充资料">补充资料</h1><p><a href="http://antonioleiva.com/" target="_blank" rel="external">Antonio Leiva</a>写了一本书<a href="http://antonioleiva.com/kotlin-android-developers-book/" target="_blank" rel="external">Kotlin for Android Developers</a>，价格实惠干货满满，值得购买。配套的源码在<a href="https://github.com/antoniolg/Kotlin-for-Android-Developers" target="_blank" rel="external">https://github.com/antoniolg/Kotlin-for-Android-Developers</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近公司新开发了一个新App，android程序员就我一个人，爱咋写咋写~~于是我尝试用Kotlin完成了这个App。开发过程中越来越感动……太好用了！！！解决了android开发中的好多痛点！</p>
<h1 id="dp,_sp,_px间的转换">dp, sp, px间]]>
    </summary>
    
      <category term="Kotlin" scheme="http://qq157755587.github.io/categories/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[快速自定义tableViewCell]]></title>
    <link href="http://qq157755587.github.io/2015/08/19/custom-table-view-cell/"/>
    <id>http://qq157755587.github.io/2015/08/19/custom-table-view-cell/</id>
    <published>2015-08-19T12:47:01.000Z</published>
    <updated>2015-08-19T13:11:43.000Z</updated>
    <content type="html"><![CDATA[<p>最近因为工作需要开始学习iOS。在网上搜自动定义tableViewCell，出来的结果都是要新建xib文件和对应的class，然后在上面添加控件，再注册到tableViewController中。<br>这样做一来很繁琐，二来很容易在绑定outlet的时候抛异常（我就遇到了）。同事告诉我一个快捷的办法。</p>
<p>1、直接在StoryBoard里面将控件添加到Prototype Cell中。</p>
<p><img src="tableViewCell.png" alt="Image of tableViewCell"></p>
<p>2、新增一个Class（比如MyTableViewCell）继承UITableViewCell。</p>
<p>3、将Prototype Cell的Class设为MyTableViewCell。</p>
<p>4、按住<em>control</em>将控件拖到MyTableViewCell中，添加outlet。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) IBOutlet UILable *label;&#10;@property (nonatomic, strong) IBOutlet UIImageView *image;</span><br></pre></td></tr></table></figure></p>
<p>5、直接调用<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CELL_IDENTITY forIndexPath:indexPath];</span><br></pre></td></tr></table></figure></p>
<p>搞定~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近因为工作需要开始学习iOS。在网上搜自动定义tableViewCell，出来的结果都是要新建xib文件和对应的class，然后在上面添加控件，再注册到tableViewController中。<br>这样做一来很繁琐，二来很容易在绑定outlet的时候抛异常（我就遇到了]]>
    </summary>
    
      <category term="tableViewCell" scheme="http://qq157755587.github.io/tags/tableViewCell/"/>
    
      <category term="iOS" scheme="http://qq157755587.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kotlin学习笔记（三）控制流程]]></title>
    <link href="http://qq157755587.github.io/2015/08/08/learning-kotlin-3/"/>
    <id>http://qq157755587.github.io/2015/08/08/learning-kotlin-3/</id>
    <published>2015-08-08T06:40:18.000Z</published>
    <updated>2015-08-08T08:06:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="If_Expression">If Expression</h1><p>在Kotlin中，<strong>if</strong>是一个表达式，它有返回类型。因此Kotlin中不再需要三元表达式。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> max</span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure>
<p>if分支也可以是代码块（blocks），代码块的末尾是返回值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> max</span> = <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">  print(<span class="string">"Choose a"</span>)</span><br><span class="line">  a <span class="comment">// a会被赋值给max</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  print(<span class="string">"Choose b"</span>)</span><br><span class="line">  b <span class="comment">// b会被赋值给max</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="When_Expression">When Expression</h1><p><strong>when</strong>替代了switch语句，简单的例子像这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">  <span class="number">1</span> -&gt; print(<span class="string">"x == 1"</span>)</span><br><span class="line">  <span class="number">2</span> -&gt; print(<span class="string">"x == 2"</span>)</span><br><span class="line">  <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">    print(<span class="string">"x is neither 1 or 2"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果多个分支使用同样的处理逻辑，那么可以用逗号将它们结合起来：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">  <span class="number">1</span>, <span class="number">2</span> -&gt; print(<span class="string">"x == 1 or x == 2"</span>)</span><br><span class="line">  <span class="keyword">else</span> -&gt; print(<span class="string">"otherwise"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分支中除了使用常量（上例中的1、2），也可以使用函数（arbitrary expressions）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">  parseInt(s) -&gt; print(<span class="string">"s encodes x"</span>)</span><br><span class="line">  esle -&gt; print(<span class="string">"s does not encode x"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以用<strong>in</strong>或<strong>!in</strong>判断一个值是否在一个范围（range）或集合（collection）中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">  <span class="keyword">in</span> <span class="number">1.</span>..<span class="number">10</span> -&gt; print(<span class="string">"x is in the range"</span>)</span><br><span class="line">  <span class="keyword">in</span> validNumbers -&gt; print(<span class="string">"x is valid"</span>)</span><br><span class="line">  !<span class="keyword">in</span> <span class="number">10.</span>..<span class="number">20</span> -&gt; print(<span class="string">"x is outside the range"</span>)</span><br><span class="line">  <span class="keyword">else</span> -&gt; print(<span class="string">"none of the above"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以用<strong>is</strong>或<strong>!is</strong>来检查一个值是否是某个类型：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> hasPrefix</span> = <span class="keyword">when</span>(x) &#123;</span><br><span class="line">  <span class="keyword">is</span> String -&gt; x.startsWith(<span class="string">"prefix"</span>) <span class="comment">// 注意这里s已经被自动转为String类型了</span></span><br><span class="line">  <span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>when还可以用来取代<strong>if-else if</strong>。如果没有传参数，那么分支条件就是简单的boolean表达式，当条件为true时分支就会被执行：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">  x.isOdd() -&gt; print(<span class="string">"x is odd"</span>)</span><br><span class="line">  x.isEven() -&gt; print(<span class="string">"x is even"</span>)</span><br><span class="line">  <span class="keyword">else</span> -&gt; print(<span class="string">"x is funny"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="For_Loops">For Loops</h1><p>感觉没什么特别的，跟Java一样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection)</span><br><span class="line">  print(item)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array.indices)</span><br><span class="line">  print(array[i])</span><br></pre></td></tr></table></figure>
<h1 id="While_Loops">While Loops</h1><p>也没什么特别的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  x--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="variable"><span class="keyword">val</span> y</span> = retrieveData()</span><br><span class="line">&#125; <span class="keyword">while</span> (y != <span class="literal">null</span>) <span class="comment">// 注意虽然y是在大括号内部定义的，但这里仍然可以访问到</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="If_Expression">If Expression</h1><p>在Kotlin中，<strong>if</strong>是一个表达式，它有返回类型。因此Kotlin中不再需要三元表达式。</p>
<figure class="highlight kotli]]>
    </summary>
    
      <category term="for" scheme="http://qq157755587.github.io/tags/for/"/>
    
      <category term="if" scheme="http://qq157755587.github.io/tags/if/"/>
    
      <category term="when" scheme="http://qq157755587.github.io/tags/when/"/>
    
      <category term="while" scheme="http://qq157755587.github.io/tags/while/"/>
    
      <category term="Kotlin" scheme="http://qq157755587.github.io/categories/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kotlin学习笔记（二）基本类型]]></title>
    <link href="http://qq157755587.github.io/2015/07/28/learning-kotlin-2/"/>
    <id>http://qq157755587.github.io/2015/07/28/learning-kotlin-2/</id>
    <published>2015-07-28T10:31:26.000Z</published>
    <updated>2015-07-30T09:51:37.000Z</updated>
    <content type="html"><![CDATA[<p>如果你学过Ruby，你一定知道“万物皆对象”。Kotlin中也一样。即便数字(Numbers)在Kotlin中是基本类型，也可以这样写：<code>123.toString()</code></p>
<p>下面我们来看一下Kotlin中的基本类型。</p>
<h1 id="Numbers">Numbers</h1><p>Kotlin提供的数字类型和Java很像：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>Type</strong></th>
<th style="text-align:center"><strong>Bitwidth</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Double</td>
<td style="text-align:center">64</td>
</tr>
<tr>
<td style="text-align:center">Float</td>
<td style="text-align:center">32</td>
</tr>
<tr>
<td style="text-align:center">Long</td>
<td style="text-align:center">64</td>
</tr>
<tr>
<td style="text-align:center">Int</td>
<td style="text-align:center">32</td>
</tr>
<tr>
<td style="text-align:center">Short</td>
<td style="text-align:center">16</td>
</tr>
<tr>
<td style="text-align:center">Byte</td>
<td style="text-align:center">8</td>
</tr>
</tbody>
</table>
<p>值得注意的是，定义Long形要用大写L：<strong>123L</strong></p>
<p>而16进制和二进制则和Java一样：<strong>0x0F</strong> <strong>0b0101</strong></p>
<p>8进制则不支持。</p>
<p>浮点型和Java一样，类似<strong>123.45</strong>默认为Double类型，想要Float类型则应写成<strong>123.45f</strong></p>
<p>在Java平台中，Number是基本类型。如果需要一个可空的数字（比如Int?）或者泛型，数字就会被装箱(boxed)：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> a</span>: <span class="typename">Int</span> = <span class="number">10000</span></span><br><span class="line">print(a == a) <span class="comment">// Prints 'true'</span></span><br><span class="line">print(a === a) <span class="comment">// Prints 'true'</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> boxedA</span>: <span class="typename">Int</span>? = a</span><br><span class="line"><span class="variable"><span class="keyword">val</span> anotherBoxedA</span>: <span class="typename">Int</span>? = a</span><br><span class="line">print(boxedA == anotherBoxedA) <span class="comment">// Prints 'true'</span></span><br><span class="line">print(boxedA === anotherBoxedA) <span class="comment">// !!!Prints 'false'!!!</span></span><br></pre></td></tr></table></figure>
<p><code>==</code>相当于调用<code>equals</code>方法。而<code>===</code>相当于Java中的<code>==</code>，用来比较引用对象。</p>
<p>注意在官方的<a href="http://kotlinlang.org/docs/reference/basic-types.html#representation" target="_blank" rel="external">Reference</a>中用的是即将被deprecated的<code>identityEquals</code>，会得到错误的结果，详情参看 <a href="http://stackoverflow.com/questions/31666155/kotlins-identityequals-not-working-as-expected" target="_blank" rel="external">http://stackoverflow.com/questions/31666155/kotlins-identityequals-not-working-as-expected</a></p>
<p>Kotlin中，数字类型<strong>不能</strong>像Java一样隐式(implicitly)转换类型。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> a</span>:<span class="typename">Int</span>? = <span class="number">1</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> b</span>:<span class="typename">Long</span>? = a <span class="comment">// 这里会编译报错，Int不能转换成Long</span></span><br><span class="line">print(a == b) <span class="comment">// 这里会编译报错，Int和Long不能进行比较</span></span><br></pre></td></tr></table></figure>
<p>而所有的数字类型都有如下显示方法：</p>
<ul>
<li>toByte()</li>
<li>toShort()</li>
<li>toInt()</li>
<li>toLong()</li>
<li>toFloat()</li>
<li>toDouble()</li>
<li>toChar()</li>
</ul>
<p>写惯Java的人可能觉得这样会很不方便，但事情也没有那么糟糕。因为运算符可以帮我们隐式的转换数字类型：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> l</span> = <span class="number">1.</span>toLong() + <span class="number">3</span> <span class="comment">// Long + Int =&gt; Long</span></span><br></pre></td></tr></table></figure>
<p>仅Int和Long可以进行位运算。运算符与Java不同：</p>
<ul>
<li>shl(bits) 有符号的左位移，在Java中是<code>&lt;&lt;</code></li>
<li>shr(bits) 有符号的右位移，在Java中是<code>&gt;&gt;</code></li>
<li>ushr(bits) 无符号的右位移，在Java中是<code>&gt;&gt;&gt;</code></li>
<li>and(bits) 与，在Java中是<code>&amp;</code></li>
<li>or(bits) 或，在Java中是<code>|</code></li>
<li>xor(bits) 异或，在Java中是<code>^</code></li>
<li>inv() 非，在Java中是<code>~</code></li>
</ul>
<h1 id="Characters">Characters</h1><p>Int不能直接转为Char，下面的代码会编译报错：</p>
<p><code>val a:Char = 1</code></p>
<p>但是Char可以通过<code>toInt()</code>方法转为Int。</p>
<p>同数字一样，如果需要一个可空类型（Char?），那么这个Char会被自动装箱（boxed）。</p>
<h1 id="Booleans">Booleans</h1><p>没什么好说的，也是自动装箱的问题。</p>
<h1 id="Arrays">Arrays</h1><p>Kotlin中的数组写法与Java区别很大，有专门的<code>Array</code>类来创建和操作数组。</p>
<p>如果我想创建一个[1, 2, 3]数组，可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> a</span>:Array<span class="type">&lt;Int&gt;</span> = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 注意这里的数字装箱了</span></span><br><span class="line">a[<span class="number">0</span>] = a[<span class="number">1</span>] + a[<span class="number">2</span>] <span class="comment">// 这里的操作与Java一样</span></span><br></pre></td></tr></table></figure>
<p>还可以像这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates an Array&lt;String&gt; with values ["0", "1", "4", "9", "16"]</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> asc</span> = Array(<span class="number">5</span>, &#123;i -&gt; (i * i).toString()&#125;)</span><br></pre></td></tr></table></figure>
<p>如果想要一个空数组，可以使用<code>arrayOfNulls(size: Int)</code>方法。</p>
<p>如果不想装箱，Kotlin也提供一些原子类型（primitive type）的数组，如<code>IntArray</code>，<code>ShortArray</code>等。这些类型没有继承<code>Array</code>类型，但是拥有相同的方法。每个类型都有对应的工厂方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> x</span>: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">x[<span class="number">0</span>] = x[<span class="number">1</span>] + x[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h1 id="Strings">Strings</h1><p><code>s.[0]</code>相当于Java中的<code>s.charAt(0)</code></p>
<p>还可以使用iterator：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (c <span class="keyword">in</span> str) &#123;</span><br><span class="line">    println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin包含两种类型的字符串：与Java字符串相同的escaped strings和新的raw strings。escaped strings中的换行符是<code>\n</code>，而raw strings就厉害了。看这个例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val text = """</span><br><span class="line">    for (c in "foo")</span><br><span class="line">    print(c)</span><br><span class="line">"""</span><br></pre></td></tr></table></figure>
<p>注意第二行和第三行都是字符串，它们被包含在三个引号中。</p>
<p>Kotlin中再也不用写繁琐的<code>String.format</code>了，只需要一个<code>$</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> i</span> = <span class="number">10</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> s</span> = <span class="string">"i = $i"</span> <span class="comment">// evaluates to "i = 10"</span></span><br></pre></td></tr></table></figure>
<p>甚至可以像这样写表达式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> s</span> = <span class="string">"abc"</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> str</span> = <span class="string">"$s.length is $&#123;s.length&#125;"</span> <span class="comment">// evaluates to "abc.length is 3"</span></span><br></pre></td></tr></table></figure>
<p><em>这篇是用<a href="http://typora.io/" target="_blank" rel="external">Typora</a>写的，确实很好用，而且是国人出品！</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果你学过Ruby，你一定知道“万物皆对象”。Kotlin中也一样。即便数字(Numbers)在Kotlin中是基本类型，也可以这样写：<code>123.toString()</code></p>
<p>下面我们来看一下Kotlin中的基本类型。</p>
<h1 id="]]>
    </summary>
    
      <category term="array" scheme="http://qq157755587.github.io/tags/array/"/>
    
      <category term="boolean" scheme="http://qq157755587.github.io/tags/boolean/"/>
    
      <category term="character" scheme="http://qq157755587.github.io/tags/character/"/>
    
      <category term="number" scheme="http://qq157755587.github.io/tags/number/"/>
    
      <category term="string" scheme="http://qq157755587.github.io/tags/string/"/>
    
      <category term="Kotlin" scheme="http://qq157755587.github.io/categories/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kotlin学习笔记（一）基本语法]]></title>
    <link href="http://qq157755587.github.io/2015/07/24/learning-kotlin-1/"/>
    <id>http://qq157755587.github.io/2015/07/24/learning-kotlin-1/</id>
    <published>2015-07-24T10:37:27.000Z</published>
    <updated>2015-07-25T12:01:07.000Z</updated>
    <content type="html"><![CDATA[<p>先提个问题</p>
<h1 id="Android程序员为什么要学Kotlin？">Android程序员为什么要学Kotlin？</h1><ol>
<li>Java不争气。在1.5时代Java或许还能和C#谈笑风生，而现在C#不知道比Java高明到哪里去了。虽然Java8中也加入了闭包等有用的特性，但Android又不支持……</li>
<li><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a>。想象这样一个需求：用户连续点击某个区域10次且每次间隔不超过500毫秒，则触发一个彩蛋。<br>实现这个需求很容易，但代码会很混乱。我们得自己控制计时器，保存时间戳，可能还会有令人讨厌的空接口。如果用RxJava来做，几行代码就能搞定。如果再配合Kotlin的函数式编程，简直不能更爽~<br>关于RxJava的使用，网上已经有很多了。我有空了可能也会写一些。</li>
<li>如果你尝试了<a href="https://developer.android.com/tools/data-binding/guide.html" target="_blank" rel="external">Android Databinding</a>，有没有发现External Libraries里面多了kotlin-runtime和kotlin-stdlib？<br>Google内部正是用Kotlin开发的Databinding。虽然短期内Kotlin还不太可能成为Android官方开发语言，但至少这是个好的迹象。</li>
</ol>
<h1 id="为什么是Kotlin？">为什么是Kotlin？</h1><p>现在替代Java的选择有很多，Scala、Groovy都能写Android，甚至微软最新发布的Visual Studio都能进来插一脚，为什么要选<a href="http://kotlinlang.org/" target="_blank" rel="external">Kotlin</a>呢？<br>这又是另一个很大的话题了。请参看大神Jake Wharton的这篇<a href="https://docs.google.com/document/d/1ReS3ep-hjxWA8kZi0YqDbEhCqTt29hG8P44aA9W0DM8/edit" target="_blank" rel="external">文章</a>（要翻墙）。</p>
<p>那么进入正题。我的学习步骤基本是按照官方的<a href="http://kotlinlang.org/docs/reference/" target="_blank" rel="external">Reference</a>来，所以可能写着写着就成了翻译官方文档了……哈哈哈哈</p>
<h1 id="Function">Function</h1><p>最开始学C的时候，我们会说为了实现XXX写个函数（Function），学Java就变成了写个方法（Method），现在Kotlin又变成函数了……<br>所以我后面提到Java的时候会说Method，提到Kotlin的时候会说Function，其实都是一个意思~</p>
<p>先看下Java中的写法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后是Kotlin<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span>: Int &#123;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>区别：</p>
<ol>
<li>用fun开头</li>
<li>数据类型写在后面</li>
<li>结尾不用写分号</li>
</ol>
<p>这语法让我想起了Action Script，写惯了Java再来写Kotlin总觉得有些别扭……</p>
<p>如果想简洁一点可以这样写在一行里，并且返回值类型可以是隐式（inferred）的。不过我个人不太喜欢这样写。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span> = a + b</span></span><br></pre></td></tr></table></figure>
<p>如果是public function就必须显式的标明返回类型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span>: Int = a + b</span></span><br></pre></td></tr></table></figure>
<p>没有返回值则用<strong>Unit</strong>关键字</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span>: Unit &#123;</span></span><br><span class="line">    print(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使函数是public的，Unit也可以省略掉<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span> &#123;</span></span><br><span class="line">    print(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="local_variables">local variables</h1><p>只读变量（read-only）用<strong>val</strong>定义<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> a</span>: <span class="typename">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> b</span> = <span class="number">1</span> <span class="comment">// 如果赋了初始值值，可以省略数据类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> c</span>: <span class="typename">Int</span> <span class="comment">// 否则需要指定类型</span></span><br><span class="line">c = <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>可变变量（mutable）用<strong>var</strong>定义<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> x</span> = <span class="number">5</span></span><br><span class="line">x += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h1 id="string_templates">string templates</h1><p>用<strong>${}</strong>包住变量就行了，这比Java中的String.valueof方便多了<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> a</span> = <span class="number">1</span></span><br><span class="line">print(<span class="string">"Value of a: $&#123;a&#125;"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="conditional_expressions">conditional expressions</h1><p>看起来有点像三元表达式，但可读性更强<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span> = <span class="title">if</span> <span class="params">(a &gt; b)</span> a <span class="keyword">else</span> b</span></span><br></pre></td></tr></table></figure></p>
<h1 id="nullable_values">nullable values</h1><p>写java的同学一定受够了NullPointerException吧。Kotlin与Java很大不同的一点就是显示的标明了value是否可能为空。<br>如果可能为空，则用<strong>?</strong>注明<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> x</span>: <span class="typename">Int</span>?</span><br></pre></td></tr></table></figure></p>
<p>先知道有这么回事就行了，后面的章节会详细说明。</p>
<h1 id="type_checks_&amp;_automatic_casts">type checks &amp; automatic casts</h1><p>和C#一样，用<strong>is</strong>操作符来判断变量的类型<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="typename">Any</span>)</span>: Int? &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">is</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj.length <span class="comment">// 注意这里obj已经自动转成String类型了，所以可以调用length方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// 这里obj依然是Any类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="loop">loop</h1><p>和Java相比是把冒号改成了<strong>in</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="typename">Array&lt;String&gt;</span>)</span> &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (arg <span class="keyword">in</span> args)</span><br><span class="line">        print(arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="while_loop">while loop</h1><p>和Java基本一样<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="typename">Array&lt;String&gt;</span>)</span> &#123; </span></span><br><span class="line">    <span class="variable"><span class="keyword">var</span> i</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (i <span class="type">&lt; args.size())</span><br><span class="line">        print(args[i++]) </span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="when_expression">when expression</h1><p><strong>when</strong>可以类比Java中的<strong>switch case</strong>，但是更加强大，可以接受各种操作符<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cases</span><span class="params">(obj: <span class="typename">Any</span>)</span> &#123; </span></span><br><span class="line">    <span class="keyword">when</span> (obj) &#123;</span><br><span class="line">        <span class="number">1</span> -&gt; print(<span class="string">"One"</span>)</span><br><span class="line">        <span class="string">"Hello"</span> -&gt; print(<span class="string">"Greeting"</span>)</span><br><span class="line">        <span class="keyword">is</span> <span class="typename">Long</span> -&gt; print(<span class="string">"Long"</span>)</span><br><span class="line">        !<span class="keyword">is</span> String -&gt; print(<span class="string">"Not a string"</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; print(<span class="string">"Unknow"</span>)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="ranges">ranges</h1><p><strong>in</strong>操作符太好用了，我就不贴对应的Java代码了，因为想想就觉得麻烦……<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x <span class="keyword">in</span> <span class="number">1.</span>.y-<span class="number">1</span>) </span><br><span class="line">    print(<span class="string">"OK"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (x !<span class="keyword">in</span> <span class="number">0.</span>.array.lastIndex) </span><br><span class="line">    print(<span class="string">"Out"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.</span>.<span class="number">5</span>) </span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure></p>
<h1 id="collections">collections</h1><p>collections配合in使用很方便<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (text <span class="keyword">in</span> names) <span class="comment">// 这里调用了names.contains(text) </span></span><br><span class="line">    print(<span class="string">"Yes"</span>)</span><br></pre></td></tr></table></figure></p>
<p>如果配合函数式编程和Lambdas表达式就不能更爽……<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names filter &#123; it.startsWith(<span class="string">"A"</span>) &#125; </span><br><span class="line">      sortBy &#123; it &#125; </span><br><span class="line">      map &#123; it.toUpperCase() &#125; </span><br><span class="line">      forEach &#123; print(it) &#125;</span><br></pre></td></tr></table></figure></p>
<p>注意这里函数前面没有小圆点（<strong>.</strong>），这个大概是特有的简写，后面再慢慢学吧~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>先提个问题</p>
<h1 id="Android程序员为什么要学Kotlin？">Android程序员为什么要学Kotlin？</h1><ol>
<li>Java不争气。在1.5时代Java或许还能和C#谈笑风生，而现在C#不知道比Java高明到哪里去了。虽然Java8中]]>
    </summary>
    
      <category term="syntax" scheme="http://qq157755587.github.io/tags/syntax/"/>
    
      <category term="Kotlin" scheme="http://qq157755587.github.io/categories/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Android中将文本转为曲线]]></title>
    <link href="http://qq157755587.github.io/2015/07/18/android-convert-text-to-curves/"/>
    <id>http://qq157755587.github.io/2015/07/18/android-convert-text-to-curves/</id>
    <published>2015-07-18T08:09:27.000Z</published>
    <updated>2015-07-20T10:24:14.000Z</updated>
    <content type="html"><![CDATA[<p>最近在Android平台上生成PDF文件时，碰到了内嵌字体的问题。大部分打印厂的机器是不支持PDF内嵌字体的，<br>所以要想将文字按指定的字体印刷出来，只能<a href="http://baike.baidu.com/subview/8597409/8551998.htm" target="_blank" rel="external">转曲</a>。</p>
<h1 id="转曲">转曲</h1><p>转曲的意思就是把文字转成曲线线段，可以想象成把文字的轮廓勾勒出来。<br>Android中的<a href="http://developer.android.com/reference/android/graphics/Paint.html#getTextPath(java.lang.String, int, int, float, float, android.graphics.Path" target="_blank" rel="external">Paint.getTextPath</a><br>方法可以获得String的Path，而<a href="http://developer.android.com/reference/android/graphics/PathMeasure.html" target="_blank" rel="external">PathMeasure</a>可以获得Path中的关键点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Paint paint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">paint.setTextSize(yourTextSize);</span><br><span class="line">Path fontPath = <span class="keyword">new</span> Path();</span><br><span class="line">paint.getTextPath(yourText, <span class="number">0</span>, yourText.length(), <span class="number">0f</span>, paint.getFontSpacing(), fontPath);</span><br><span class="line">PathMeasure pathMeasure = <span class="keyword">new</span> PathMeasure(fontPath, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">float</span>[] pos = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">2</span>]; <span class="comment">// pos用来存放每一个关键点</span></span><br><span class="line">do &#123;</span><br><span class="line">    <span class="keyword">float</span> distance = <span class="number">0f</span>;</span><br><span class="line">    <span class="keyword">while</span> (distance &lt; pathMeasure.getLength()) &#123;</span><br><span class="line">        pathMeasure.getPosTan(distance, pos, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 在这里将pos设置到你自己的曲线里</span></span><br><span class="line">        <span class="comment">// 我使用PDFjet生成PDF，那么这里就将pos保存到com.pdfjet.Point中</span></span><br><span class="line">        distance += <span class="number">0.1f</span>; <span class="comment">// 0.1f是每个关键点的间隔。间隔越大轮廓越粗糙，反之越细腻。如果设的过小会影响性能。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (pathMeasure.nextContour());<span class="comment">// nextContour会跳到下一段曲线</span></span><br></pre></td></tr></table></figure>
<h1 id="计算曲线嵌套层数">计算曲线嵌套层数</h1><p>得到文字曲线后还不能直接印刷，因为我们只是得到了文字的轮廓，还得往轮廓里填色。<br>当然不能所有轮廓都填黑色，这样文字会变成一坨一坨的黑色……<br>我们需要计算每条曲线被多少条曲线全包围（注意我们现在得到的曲线全都是头尾相连的）。<br>如果被偶数条曲线（包含0条）包围，则填黑色；如果被奇数条曲线包围，则填白色（底色）。<br>Android或Java本身不提供这样的方法，还好已经有人帮我们研究出方法了，详细参看<a href="http://alienryderflex.com/polygon/。" target="_blank" rel="external">http://alienryderflex.com/polygon/。</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Polygon coodinates.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span>[] polyY, polyX;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Number of sides in the polygon.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> polySides;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Default constructor.</span><br><span class="line">     * <span class="doctag">@param</span> px Polygon y coods.</span><br><span class="line">     * <span class="doctag">@param</span> py Polygon x coods.</span><br><span class="line">     * <span class="doctag">@param</span> ps Polygon sides count.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Polygon</span><span class="params">( <span class="keyword">float</span>[] px, <span class="keyword">float</span>[] py, <span class="keyword">int</span> ps )</span> </span>&#123;</span><br><span class="line">        polyX = px;</span><br><span class="line">        polyY = py;</span><br><span class="line">        polySides = ps;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Checks if the Polygon contains a point.</span><br><span class="line">     * <span class="doctag">@see</span> "http://alienryderflex.com/polygon/"</span><br><span class="line">     * <span class="doctag">@param</span> x Point horizontal pos.</span><br><span class="line">     * <span class="doctag">@param</span> y Point vertical pos.</span><br><span class="line">     * <span class="doctag">@return</span> Point is in Poly flag.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">( <span class="keyword">float</span> x, <span class="keyword">float</span> y )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> oddTransitions = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>, j = polySides -<span class="number">1</span>; i &lt; polySides; j = i++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span>((Float.compare(polyY[i], y) &lt; <span class="number">0</span> &amp;&amp; Float.compare(polyY[j], y) &gt;= <span class="number">0</span> ) || ( Float.compare(polyY[j], y) &lt; <span class="number">0</span> &amp;&amp; Float.compare(polyY[i], y) &gt;= <span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(Float.compare(polyX[i] + ( y - polyY[i] ) / ( polyY[j] - polyY[i] ) * ( polyX[j] - polyX[i] ), x) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    oddTransitions = !oddTransitions;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oddTransitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Polygon的构造方法前两个参数填多边形（可以将曲线理解为多边形）横坐标和纵坐标的数组，第三个参数填多边形的边数，即坐标的个数。<br>contains方法即可检查某个点是否在这个多边形中。<br>那么思路就很简单了：如果曲线A的任一关键点不在曲线B中，B就没有包围A。<br>代码就不贴了。</p>
<h1 id="填色">填色</h1><p>如上所述，如果被偶数条曲线包围，填黑色；被奇数条曲线包围，填白色。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nestingNum = surroundedNumber(pathPointsList, pathPoints);</span><br><span class="line"><span class="keyword">if</span> (nestingNum % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    paint.setColor(Color.BLACK);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    paint.setColor(Color.WHITE);</span><br><span class="line">&#125;</span><br><span class="line">canvas.drawPath(path, paint);</span><br></pre></td></tr></table></figure>
<p>大功告成~</p>
<p>详细代码请参考<a href="https://gist.github.com/qq157755587/32e927e77e259cd84631" target="_blank" rel="external">https://gist.github.com/qq157755587/32e927e77e259cd84631</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在Android平台上生成PDF文件时，碰到了内嵌字体的问题。大部分打印厂的机器是不支持PDF内嵌字体的，<br>所以要想将文字按指定的字体印刷出来，只能<a href="http://baike.baidu.com/subview/8597409/8551998.ht]]>
    </summary>
    
      <category term="PDF" scheme="http://qq157755587.github.io/tags/PDF/"/>
    
      <category term="Paint" scheme="http://qq157755587.github.io/tags/Paint/"/>
    
      <category term="Path" scheme="http://qq157755587.github.io/tags/Path/"/>
    
      <category term="Android" scheme="http://qq157755587.github.io/categories/Android/"/>
    
  </entry>
  
</feed>